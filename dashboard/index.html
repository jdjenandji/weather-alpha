<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weather Alpha Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3/dist/chartjs-plugin-annotation.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', system-ui, sans-serif; background: #0a0a0f; color: #e0e0e0; padding: 20px; }
  h1 { font-size: 1.4em; color: #fff; margin-bottom: 4px; }
  .subtitle { color: #666; font-size: 0.85em; margin-bottom: 20px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); gap: 16px; margin-bottom: 24px; }
  .card { background: #13131a; border: 1px solid #1e1e2e; border-radius: 12px; padding: 16px; }
  .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
  .city-name { font-weight: 600; font-size: 1.1em; }
  .date-badge { background: #1e1e2e; padding: 3px 10px; border-radius: 20px; font-size: 0.8em; color: #888; }
  .signal { padding: 4px 10px; border-radius: 6px; font-size: 0.8em; font-weight: 600; display: inline-block; margin-bottom: 10px; }
  .signal-strong { background: #0f3d0f; color: #4ade80; border: 1px solid #166534; }
  .signal-marginal { background: #3d3d0f; color: #facc15; border: 1px solid #854d0e; }
  .signal-skip { background: #2d1215; color: #f87171; border: 1px solid #7f1d1d; }
  .models { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 10px; }
  .model-box { background: #0a0a12; border-radius: 8px; padding: 8px; text-align: center; }
  .model-name { font-size: 0.7em; color: #666; text-transform: uppercase; letter-spacing: 0.5px; }
  .model-val { font-size: 1.2em; font-weight: 700; margin-top: 2px; }
  .model-bucket { font-size: 0.75em; color: #888; }
  .agree { color: #4ade80; }
  .disagree { color: #f87171; }
  .market-row { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #1a1a2a; font-size: 0.85em; }
  .market-row:last-child { border: none; }
  .market-row.target { background: #0f2d0f; margin: 0 -8px; padding: 4px 8px; border-radius: 4px; }
  .bar-container { width: 80px; height: 6px; background: #1a1a2a; border-radius: 3px; overflow: hidden; }
  .bar { height: 100%; border-radius: 3px; }
  .bar-green { background: #4ade80; }
  .bar-yellow { background: #facc15; }
  .bar-gray { background: #444; }
  .edge-box { margin-top: 10px; padding: 10px; background: #0a0a12; border-radius: 8px; display: flex; justify-content: space-between; gap: 12px; }
  .edge-label { font-size: 0.75em; color: #666; }
  .edge-value { font-size: 1.1em; font-weight: 700; }
  .edge-positive { color: #4ade80; }
  .edge-negative { color: #f87171; }
  .summary-bar { display: flex; gap: 16px; margin-bottom: 20px; flex-wrap: wrap; }
  .stat { background: #13131a; border: 1px solid #1e1e2e; border-radius: 10px; padding: 12px 20px; min-width: 120px; }
  .stat-label { font-size: 0.7em; color: #666; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-value { font-size: 1.4em; font-weight: 700; margin-top: 2px; }
  .refresh-btn { background: #1e1e2e; border: 1px solid #2e2e3e; color: #888; padding: 6px 16px; border-radius: 8px; cursor: pointer; font-size: 0.85em; }
  .refresh-btn:hover { background: #2e2e3e; color: #fff; }
  .loading { color: #666; font-style: italic; }
  #lastUpdate { color: #444; font-size: 0.8em; }
  .section-title { font-size: 1em; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 1px; margin: 28px 0 12px; padding-bottom: 6px; border-bottom: 1px solid #1e1e2e; }
  .chart-container { background: #13131a; border: 1px solid #1e1e2e; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
  .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
  .chart-title { font-weight: 600; font-size: 1em; }
  .date-selector { display: flex; gap: 6px; }
  .date-btn { background: #1e1e2e; border: 1px solid #2e2e3e; color: #888; padding: 3px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8em; }
  .date-btn.active { background: #0f3d0f; color: #4ade80; border-color: #166534; }
  .chart-wrap { height: 250px; position: relative; }
  .no-data { color: #555; font-size: 0.85em; text-align: center; padding: 60px 0; }
  .tab-bar { display: flex; gap: 8px; margin-bottom: 16px; }
  .tab { background: #1e1e2e; border: 1px solid #2e2e3e; color: #888; padding: 6px 16px; border-radius: 8px; cursor: pointer; font-size: 0.85em; }
  .tab.active { background: #0f3d0f; color: #4ade80; border-color: #166534; }
</style>
</head>
<body>

<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 4px;">
  <h1>ğŸŒ¡ï¸ Weather Alpha</h1>
  <button class="refresh-btn" onclick="refresh()">â†» Refresh</button>
</div>
<div class="subtitle">ECMWF IFS + Multi-Model Consensus Â· Polymarket Weather Markets Â· Tier 1 Only <span id="lastUpdate"></span></div>

<div class="summary-bar" id="summaryBar">
  <div class="stat"><div class="stat-label">Signals</div><div class="stat-value" id="signalCount">â€”</div></div>
  <div class="stat"><div class="stat-label">Strong</div><div class="stat-value edge-positive" id="strongCount">â€”</div></div>
  <div class="stat"><div class="stat-label">Marginal</div><div class="stat-value" style="color:#facc15" id="marginalCount">â€”</div></div>
  <div class="stat"><div class="stat-label">Best Edge</div><div class="stat-value edge-positive" id="bestEdge">â€”</div></div>
  <div class="stat"><div class="stat-label">Data Points</div><div class="stat-value" id="dataPoints">â€”</div></div>
</div>

<div class="tab-bar">
  <div class="tab active" onclick="switchTab('live')">ğŸ“¡ Live Signals</div>
  <div class="tab" onclick="switchTab('charts')">ğŸ“ˆ Delta Charts</div>
  <div class="tab" onclick="switchTab('trades')">ğŸ’° Trades</div>
  <div class="tab" onclick="switchTab('backtest')">ğŸ“Š Backtest</div>
  <div class="tab" onclick="switchTab('drops')">ğŸ”” Model Drops</div>
  <div class="tab" onclick="switchTab('efficiency')">â±ï¸ Market Lag</div>
  <div class="tab" onclick="switchTab('accuracy')">ğŸ• Accuracy by Run</div>
  <div class="tab" onclick="switchTab('logic')">ğŸ§  Trading Logic</div>
</div>

<div id="liveTab">
  <div class="grid" id="dashboard">
    <div class="card"><div class="loading">Loading...</div></div>
  </div>
</div>

<div id="chartsTab" style="display:none">
  <div id="chartArea"></div>
</div>

<div id="logicTab" style="display:none">
  <div style="max-width:900px">

    <div class="card" style="margin-bottom:16px;border-left:3px solid #4ade80">
      <div style="font-size:1.2em;font-weight:700;margin-bottom:12px">ğŸ§  Trading Logic v3</div>
      <div style="font-size:0.85em;color:#888;margin-bottom:16px">Updated Feb 20 2026 â€” based on real forecast accuracy from 90-day Previous Runs API backfill (not reanalysis)</div>

      <div style="background:#0a0a12;border-radius:8px;padding:16px;margin-bottom:16px">
        <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">Core Rules</div>
        <div style="display:flex;flex-direction:column;gap:8px;font-size:0.9em">
          <div>1ï¸âƒ£ <strong style="color:#4ade80">D+0 is king</strong> â€” Only same-day forecasts have real edge. D+1 accuracy drops 20-45pp. D+2 is noise for most cities. Prioritize D+0 trades.</div>
          <div>2ï¸âƒ£ <strong style="color:#4ade80">ECMWF must agree</strong> â€” If ECMWF disagrees with the consensus bucket, skip. ECMWF alone at D+0: London 86%, Paris 68%, Chicago 78%.</div>
          <div>3ï¸âƒ£ <strong style="color:#facc15">Per-city consensus threshold</strong> â€” London â‰¥1/3 (ECMWF alone is good enough), Paris and Chicago need 3/3.</div>
          <div>4ï¸âƒ£ <strong style="color:#60a5fa">Lead-time-dependent confidence</strong> â€” Edge = conf[leadDays][agreement] âˆ’ market price. Conf values from real Previous Runs accuracy. Must exceed 15% for strong signal.</div>
          <div>5ï¸âƒ£ <strong style="color:#a78bfa">Monitor for shifts</strong> â€” Model runs update 2-4x/day. Track ECMWF 00z/12z, GFS/ICON 00z/06z/12z/18z drops. If consensus breaks after entry, flag as BROKEN.</div>
        </div>
      </div>

      <div style="background:#2d1215;border:1px solid #7f1d1d;border-radius:8px;padding:12px;margin-bottom:16px;font-size:0.85em">
        <div style="font-weight:700;color:#f87171;margin-bottom:4px">âš ï¸ v2 â†’ v3 breaking change</div>
        <div style="color:#fca5a5">v2 used flat confidence values (e.g. 83% for â‰¥2/3 everywhere). This was based on a flawed backtest that used ERA5 reanalysis instead of real forecasts. v3 uses measured accuracy by lead time. Many trades that showed "STRONG" in v2 now correctly show "NO EDGE" â€” especially D+1/D+2 trades for Paris and Chicago.</div>
      </div>
    </div>

    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">Active Markets</div>
    <div class="grid" style="margin-bottom:16px">

      <div class="card" style="border-left:3px solid #4ade80">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <span style="font-weight:700;font-size:1.1em">ğŸ‡¬ğŸ‡§ London</span>
          <span style="background:#0f3d0f;color:#4ade80;padding:3px 10px;border-radius:6px;font-size:0.8em;font-weight:600">PRIMARY</span>
        </div>
        <div style="font-size:0.85em;color:#aaa;margin-bottom:10px">Station: EGLC (London City Airport) Â· 1Â°C buckets</div>
        <div style="font-size:0.75em;color:#888;margin-bottom:4px">Real accuracy (90-day Previous Runs backfill)</div>
        <table style="width:100%;border-collapse:collapse;font-size:0.8em;text-align:center">
          <tr style="color:#666"><td></td><td>D+0</td><td>D+1</td><td>D+2</td></tr>
          <tr><td style="text-align:left;color:#888">ECMWF</td><td style="color:#4ade80;font-weight:700">85.6%</td><td style="color:#facc15">63.3%</td><td style="color:#f87171">55.6%</td></tr>
          <tr><td style="text-align:left;color:#888">â‰¥2/3</td><td style="color:#4ade80;font-weight:700">83.3%</td><td style="color:#f87171">57.5%</td><td style="color:#f87171">55.1%</td></tr>
          <tr><td style="text-align:left;color:#888">3/3</td><td style="color:#4ade80;font-weight:700">90.6%</td><td style="color:#facc15">68.0%</td><td style="color:#facc15">65.4%</td></tr>
        </table>
        <div style="margin-top:8px;font-size:0.8em;color:#555">MAE D+0: 0.17Â°C Â· Min consensus: â‰¥1/3 Â· Best market by far</div>
      </div>

      <div class="card" style="border-left:3px solid #60a5fa">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <span style="font-weight:700;font-size:1.1em">ğŸ‡«ğŸ‡· Paris</span>
          <span style="background:#1e1e2e;color:#facc15;padding:3px 10px;border-radius:6px;font-size:0.8em;font-weight:600">3/3 ONLY</span>
        </div>
        <div style="font-size:0.85em;color:#aaa;margin-bottom:10px">Station: LFPG (CDG Airport) Â· 1Â°C buckets</div>
        <div style="font-size:0.75em;color:#888;margin-bottom:4px">Real accuracy (90-day Previous Runs backfill)</div>
        <table style="width:100%;border-collapse:collapse;font-size:0.8em;text-align:center">
          <tr style="color:#666"><td></td><td>D+0</td><td>D+1</td><td>D+2</td></tr>
          <tr><td style="text-align:left;color:#888">ECMWF</td><td style="color:#facc15">67.8%</td><td style="color:#f87171">48.9%</td><td style="color:#f87171">30.0%</td></tr>
          <tr><td style="text-align:left;color:#888">â‰¥2/3</td><td style="color:#facc15">66.2%</td><td style="color:#f87171">43.8%</td><td style="color:#f87171">32.4%</td></tr>
          <tr><td style="text-align:left;color:#888">3/3</td><td style="color:#facc15">76.2%</td><td style="color:#f87171">47.1%</td><td style="color:#f87171">33.3%</td></tr>
        </table>
        <div style="margin-top:8px;font-size:0.8em;color:#555">MAE D+0: 0.29Â°C Â· Min consensus: 3/3 Â· D+1/D+2 barely above chance</div>
      </div>

      <div class="card" style="border-left:3px solid #facc15">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <span style="font-weight:700;font-size:1.1em">ğŸ‡ºğŸ‡¸ Chicago</span>
          <span style="background:#1e1e2e;color:#facc15;padding:3px 10px;border-radius:6px;font-size:0.8em;font-weight:600">3/3 ONLY</span>
        </div>
        <div style="font-size:0.85em;color:#aaa;margin-bottom:10px">Station: KORD (O'Hare Airport) Â· 2Â°F buckets</div>
        <div style="font-size:0.75em;color:#888;margin-bottom:4px">Real accuracy (90-day Previous Runs backfill)</div>
        <table style="width:100%;border-collapse:collapse;font-size:0.8em;text-align:center">
          <tr style="color:#666"><td></td><td>D+0</td><td>D+1</td><td>D+2</td></tr>
          <tr><td style="text-align:left;color:#888">ECMWF</td><td style="color:#facc15">77.8%</td><td style="color:#f87171">32.2%</td><td style="color:#f87171">16.7%</td></tr>
          <tr><td style="text-align:left;color:#888">â‰¥2/3</td><td style="color:#facc15">65.6%</td><td style="color:#f87171">27.3%</td><td style="color:#f87171">23.4%</td></tr>
          <tr><td style="text-align:left;color:#888">3/3</td><td style="color:#4ade80">81.8%</td><td style="color:#f87171">16.7%</td><td style="color:#f87171">12.5%</td></tr>
        </table>
        <div style="margin-top:8px;font-size:0.8em;color:#555">MAE D+0: 0.42Â°F Â· Min consensus: 3/3 Â· D+1+ is a coin flip â€” 2Â°F buckets too hard</div>
      </div>

    </div>

    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">Removed Markets</div>
    <div class="card" style="margin-bottom:16px;opacity:0.6">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <span style="font-weight:700">ğŸ‡¦ğŸ‡· Buenos Aires</span>
        <span style="background:#2d1215;color:#f87171;padding:3px 10px;border-radius:6px;font-size:0.8em;font-weight:600">REMOVED</span>
      </div>
      <div style="font-size:0.85em;color:#666;margin-top:6px">60% consensus rate Â· 3/3 fires only 3% of days Â· GFS 21% match Â· Not tradeable</div>
    </div>

    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">Signal Flow (v3)</div>
    <div class="card" style="margin-bottom:16px">
      <div style="font-family:monospace;font-size:0.85em;line-height:2;color:#aaa">
        <div>â”Œâ”€ Fetch ECMWF, GFS, ICON forecasts from Open-Meteo</div>
        <div>â”œâ”€ Compute bucket for each model (1Â°C or 2Â°F)</div>
        <div>â”œâ”€ Find consensus bucket (most common)</div>
        <div>â”œâ”€ Compute lead time: D+0 (today), D+1 (tomorrow), D+2</div>
        <div>â”œâ”€ <span style="color:#f87171">ECMWF disagrees with consensus? â†’ SKIP</span></div>
        <div>â”œâ”€ <span style="color:#f87171">Below city minConsensus (London â‰¥1, Paris/Chicago â‰¥3)? â†’ SKIP</span></div>
        <div>â”œâ”€ Look up confidence = conf[leadDays][agreement]</div>
        <div>â”‚  <span style="color:#555">e.g. London D+0 â‰¥2/3 â†’ 83%, London D+1 â‰¥2/3 â†’ 58%</span></div>
        <div>â”œâ”€ Fetch Polymarket odds for consensus bucket</div>
        <div>â”œâ”€ Calculate edge = confidence âˆ’ market_price</div>
        <div>â”œâ”€ <span style="color:#f87171">Edge â‰¤ 5%? â†’ SKIP (NO EDGE)</span></div>
        <div>â”œâ”€ <span style="color:#facc15">Edge 5-15%? â†’ âš ï¸ MARGINAL</span></div>
        <div>â”œâ”€ <span style="color:#4ade80">Edge > 15%? â†’ ğŸ”¥ STRONG â†’ PAPER TRADE</span></div>
        <div>â”œâ”€ Store forecast snapshot with lead_days + model_run tag</div>
        <div>â”œâ”€ Fetch order book depth at entry price</div>
        <div>â”œâ”€ Every 15 min: monitor for forecast shifts</div>
        <div>â”‚  â”œâ”€ All models still agree â†’ âœ… HOLDING</div>
        <div>â”‚  â”œâ”€ 1 model drifted â†’ âš ï¸ DRIFTING</div>
        <div>â”‚  â””â”€ Consensus flipped â†’ ğŸš¨ BROKEN</div>
        <div>â”œâ”€ Model drop windows: extra collection at</div>
        <div>â”‚  â”œâ”€ ECMWF 00z (~05:30 UTC), 12z (~17:30 UTC)</div>
        <div>â”‚  â”œâ”€ GFS/ICON 00z (~04:00), 06z (~10:00), 12z (~16:00), 18z (~22:00)</div>
        <div>â”‚  â””â”€ ğŸ”” Log forecast changes + bucket flips</div>
        <div>â””â”€ Next day: auto-resolve via ERA5 archive â†’ WON/LOST + P&L</div>
      </div>
    </div>

    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">Confidence Matrix (from real data)</div>
    <div class="card" style="margin-bottom:16px">
      <div style="font-size:0.85em;color:#888;margin-bottom:8px">conf[leadDays][agreement] â€” used to compute edge. Source: 90-day Previous Runs API backfill.</div>
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px">
        <div>
          <div style="font-weight:700;margin-bottom:4px">ğŸ‡¬ğŸ‡§ London</div>
          <table style="width:100%;border-collapse:collapse;font-size:0.8em;text-align:center">
            <tr style="color:#666"><td></td><td>â‰¥1/3</td><td>â‰¥2/3</td><td>3/3</td></tr>
            <tr><td style="text-align:left;color:#888">D+0</td><td style="color:#4ade80">81%</td><td style="color:#4ade80">83%</td><td style="color:#4ade80">91%</td></tr>
            <tr><td style="text-align:left;color:#888">D+1</td><td style="color:#f87171">57%</td><td style="color:#f87171">58%</td><td style="color:#facc15">68%</td></tr>
            <tr><td style="text-align:left;color:#888">D+2</td><td style="color:#f87171">52%</td><td style="color:#f87171">55%</td><td style="color:#facc15">65%</td></tr>
          </table>
        </div>
        <div>
          <div style="font-weight:700;margin-bottom:4px">ğŸ‡«ğŸ‡· Paris</div>
          <table style="width:100%;border-collapse:collapse;font-size:0.8em;text-align:center">
            <tr style="color:#666"><td></td><td>â‰¥1/3</td><td>â‰¥2/3</td><td>3/3</td></tr>
            <tr><td style="text-align:left;color:#888">D+0</td><td style="color:#facc15">61%</td><td style="color:#facc15">66%</td><td style="color:#facc15">76%</td></tr>
            <tr><td style="text-align:left;color:#888">D+1</td><td style="color:#f87171">42%</td><td style="color:#f87171">44%</td><td style="color:#f87171">47%</td></tr>
            <tr><td style="text-align:left;color:#888">D+2</td><td style="color:#f87171">32%</td><td style="color:#f87171">32%</td><td style="color:#f87171">33%</td></tr>
          </table>
        </div>
        <div>
          <div style="font-weight:700;margin-bottom:4px">ğŸ‡ºğŸ‡¸ Chicago</div>
          <table style="width:100%;border-collapse:collapse;font-size:0.8em;text-align:center">
            <tr style="color:#666"><td></td><td>â‰¥1/3</td><td>â‰¥2/3</td><td>3/3</td></tr>
            <tr><td style="text-align:left;color:#888">D+0</td><td style="color:#facc15">70%</td><td style="color:#facc15">66%</td><td style="color:#4ade80">82%</td></tr>
            <tr><td style="text-align:left;color:#888">D+1</td><td style="color:#f87171">30%</td><td style="color:#f87171">27%</td><td style="color:#f87171">17%</td></tr>
            <tr><td style="text-align:left;color:#888">D+2</td><td style="color:#f87171">22%</td><td style="color:#f87171">23%</td><td style="color:#f87171">13%</td></tr>
          </table>
        </div>
      </div>
    </div>

    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">Key Learnings</div>
    <div class="card" style="margin-bottom:16px">
      <div style="display:flex;flex-direction:column;gap:12px;font-size:0.9em">
        <div>
          <div style="font-weight:600;color:#f87171;margin-bottom:2px">ğŸš¨ Reanalysis backtests are lies</div>
          <div style="color:#888">Our original backtest used ERA5 reanalysis as "forecasts" â€” these are corrected with observations after the fact. Real accuracy from Previous Runs API is much lower. Always use actual forecast snapshots.</div>
        </div>
        <div>
          <div style="font-weight:600;color:#f87171;margin-bottom:2px">ğŸ“‰ Accuracy crashes after D+0</div>
          <div style="color:#888">London ECMWF: D+0 86%, D+1 63%, D+2 56%. Paris: D+0 68%, D+1 49%. Chicago: D+0 78%, D+1 32%. Only same-day forecasts have tradeable edge. D+1/D+2 are barely profitable.</div>
        </div>
        <div>
          <div style="font-weight:600;color:#4ade80;margin-bottom:2px">ğŸ† ECMWF D+0 is the only reliable signal</div>
          <div style="color:#888">86% bucket match on same-day London forecasts (MAE 0.17Â°C). This is where the real edge lives. Other models and longer lead times are noise.</div>
        </div>
        <div>
          <div style="font-weight:600;color:#facc15;margin-bottom:2px">âš ï¸ GFS and ICON add little value</div>
          <div style="color:#888">GFS D+0: London 68%, Paris 44%, Chicago 24%. ICON D+0: London 51%, Paris 48%. Consensus helps but the edge comes from ECMWF alone.</div>
        </div>
        <div>
          <div style="font-weight:600;color:#60a5fa;margin-bottom:2px">ğŸ¯ 3/3 consensus D+0 is gold</div>
          <div style="color:#888">London 91%, Paris 76%, Chicago 82% â€” but only at D+0. At D+1, 3/3 consensus drops to 68% (London), 47% (Paris), 17% (Chicago).</div>
        </div>
        <div>
          <div style="font-weight:600;color:#a78bfa;margin-bottom:2px">ğŸ’¡ Lead-time-dependent confidence is essential</div>
          <div style="color:#888">Using flat conf values (e.g. 83% for â‰¥2/3) massively overstates edge on D+1/D+2 trades. Confidence must be indexed by [leadDays][agreement]. This was the single biggest correction to the system.</div>
        </div>
        <div>
          <div style="font-weight:600;color:#f87171;margin-bottom:2px">ğŸš« Paris and Chicago D+1+ are untradeable</div>
          <div style="color:#888">Paris consensus D+1: 44%. Chicago consensus D+1: 27%. These are worse than guessing the most likely bucket. Only trade D+0 or skip entirely.</div>
        </div>
      </div>
    </div>

    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">Data Sources</div>
    <div class="card">
      <div style="display:grid;grid-template-columns:auto 1fr;gap:6px 16px;font-size:0.85em">
        <span style="color:#666">Forecasts</span><span>Open-Meteo (ECMWF IFS 0.25Â°, GFS Seamless, ICON Seamless)</span>
        <span style="color:#666">Accuracy data</span><span>Open-Meteo Previous Runs API (real forecast snapshots, not reanalysis)</span>
        <span style="color:#666">Market data</span><span>Polymarket Gamma API + CLOB order book</span>
        <span style="color:#666">Resolution</span><span>Weather Underground (airport METAR stations)</span>
        <span style="color:#666">Actuals (backtest)</span><span>ERA5 reanalysis via Open-Meteo Archive API</span>
        <span style="color:#666">Model schedules</span><span>ECMWF: 00z ~05:30, 12z ~17:30 Â· GFS/ICON: 00z/06z/12z/18z (~4h after init)</span>
        <span style="color:#666">Collection</span><span>Every 15 min + extra runs during model drop windows (6 windows/day)</span>
        <span style="color:#666">Storage</span><span>Supabase (forecasts, market_prices, signals, trades, forecast_accuracy, order_depth)</span>
      </div>
    </div>

  </div>
</div>

<div id="backtestTab" style="display:none">
  <div id="backtestArea"><div class="card"><div class="loading">Loading...</div></div></div>
</div>

<div id="efficiencyTab" style="display:none">
  <div style="margin-bottom:12px;display:flex;gap:8px;flex-wrap:wrap" id="effFilters"></div>
  <div id="effArea"><div class="card"><div class="loading">Loading market efficiency data...</div></div></div>
</div>

<div id="dropsTab" style="display:none">
  <div style="margin-bottom:12px;display:flex;gap:8px;flex-wrap:wrap" id="dropsFilters"></div>
  <div id="dropsArea"><div class="card"><div class="loading">Loading model drops...</div></div></div>
</div>

<div id="accuracyTab" style="display:none">
  <div id="accuracyArea"><div class="card"><div class="loading">Loading accuracy data...</div></div></div>
</div>

<div id="tradesTab" style="display:none">
  <div id="tradesStats" class="summary-bar" style="margin-bottom:16px"></div>
  <div id="tradesArea">
    <div class="card"><div class="loading">Loading trades...</div></div>
  </div>
</div>

<script>
const SUPABASE_URL = 'https://jbqkskwfjbejixyiuqpn.supabase.co';
const SUPABASE_KEY = 'sb_publishable_6TopOsnadhqteb8xltZiZw_epDDV-cm';
const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

const CITIES = [
  // Real accuracy from 90-day Previous Runs backfill: conf[leadDays][agreement]
  { name: "London", slug: "london", unit: "C", minConsensus: 1, tier: 'primary', flag: 'ğŸ‡¬ğŸ‡§',
    conf: { 0: { 1: 0.81, 2: 0.83, 3: 0.91 }, 1: { 1: 0.57, 2: 0.58, 3: 0.68 }, 2: { 1: 0.52, 2: 0.55, 3: 0.65 } } },
  { name: "Paris", slug: "paris", unit: "C", minConsensus: 3, tier: 'secondary', flag: 'ğŸ‡«ğŸ‡·',
    conf: { 0: { 1: 0.61, 2: 0.66, 3: 0.76 }, 1: { 1: 0.42, 2: 0.44, 3: 0.47 }, 2: { 1: 0.32, 2: 0.32, 3: 0.33 } } },
  { name: "Chicago", slug: "chicago", unit: "F", minConsensus: 3, tier: 'secondary', flag: 'ğŸ‡ºğŸ‡¸',
    conf: { 0: { 1: 0.70, 2: 0.66, 3: 0.82 }, 1: { 1: 0.30, 2: 0.27, 3: 0.17 }, 2: { 1: 0.22, 2: 0.23, 3: 0.13 } } },
];

const charts = {};
let currentTab = 'live';

function switchTab(tab) {
  currentTab = tab;
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');
  document.getElementById('liveTab').style.display = tab === 'live' ? '' : 'none';
  document.getElementById('chartsTab').style.display = tab === 'charts' ? '' : 'none';
  document.getElementById('tradesTab').style.display = tab === 'trades' ? '' : 'none';
  document.getElementById('backtestTab').style.display = tab === 'backtest' ? '' : 'none';
  document.getElementById('efficiencyTab').style.display = tab === 'efficiency' ? '' : 'none';
  document.getElementById('dropsTab').style.display = tab === 'drops' ? '' : 'none';
  document.getElementById('accuracyTab').style.display = tab === 'accuracy' ? '' : 'none';
  document.getElementById('logicTab').style.display = tab === 'logic' ? '' : 'none';
  if (tab === 'charts') loadCharts();
  if (tab === 'trades') loadTrades();
  if (tab === 'backtest') loadBacktest();
  if (tab === 'efficiency') loadEfficiency();
  if (tab === 'drops') loadDrops();
  if (tab === 'accuracy') loadAccuracy();
}

function getConf(city, leadDays, agreement) {
  const ld = Math.min(leadDays, 2);
  return city.conf?.[ld]?.[Math.min(agreement, 3)] || 0;
}

function getBucket(val, unit) {
  if (unit === "F") { const b = Math.floor(val / 2) * 2; return `${b} to ${b+1}Â°F`; }
  return `${Math.round(val)}Â°C`;
}

function formatPolymarketDate(dateStr) {
  const d = new Date(dateStr + "T00:00:00Z");
  const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
  return `${months[d.getUTCMonth()]}-${d.getUTCDate()}-${d.getUTCFullYear()}`;
}

function getDates() {
  const dates = [];
  for (let i = 0; i <= 0; i++) { // D+0 only â€” D+1/D+2 have no real edge
    const d = new Date(); d.setUTCDate(d.getUTCDate() + i);
    dates.push(d.toISOString().slice(0, 10));
  }
  return dates;
}

async function fetchForecasts(city, dateStr) {
  const u = city.unit === "F" ? "&temperature_unit=fahrenheit" : "";
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${city.lat || CITIES.find(c=>c.slug===city.slug)?.lat}&longitude=${city.lon || CITIES.find(c=>c.slug===city.slug)?.lon}&daily=temperature_2m_max&timezone=UTC&start_date=${dateStr}&end_date=${dateStr}&models=ecmwf_ifs025,gfs_seamless,icon_seamless${u}`;
  const data = await (await fetch(url)).json();
  const result = {};
  for (const [k, v] of Object.entries(data.daily || {})) {
    if (k.startsWith("temperature_2m_max_")) {
      let model = k.replace("temperature_2m_max_", "").replace("_seamless", "").replace("_ifs025", "");
      if (v[0] != null) result[model] = v[0];
    }
  }
  return result;
}

const CITY_COORDS = {
  "london": { lat: 51.5053, lon: 0.0553 },
  "paris": { lat: 49.0097, lon: 2.5479 },
  "chicago": { lat: 41.9742, lon: -87.9073 },
};

async function fetchForecastsLive(slug, unit, dateStr) {
  const c = CITY_COORDS[slug];
  const u = unit === "F" ? "&temperature_unit=fahrenheit" : "";
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${c.lat}&longitude=${c.lon}&daily=temperature_2m_max&timezone=UTC&start_date=${dateStr}&end_date=${dateStr}&models=ecmwf_ifs025,gfs_seamless,icon_seamless${u}`;
  const data = await (await fetch(url)).json();
  const result = {};
  for (const [k, v] of Object.entries(data.daily || {})) {
    if (k.startsWith("temperature_2m_max_")) {
      let model = k.replace("temperature_2m_max_", "").replace("_seamless", "").replace("_ifs025", "");
      if (v[0] != null) result[model] = v[0];
    }
  }
  return result;
}

async function fetchMarketLive(slug, dateStr) {
  // Try Polymarket API directly first
  const fmtDate = formatPolymarketDate(dateStr);
  const eventSlug = `highest-temperature-in-${slug}-on-${fmtDate}`;
  try {
    const data = await (await fetch(`https://gamma-api.polymarket.com/events?slug=${eventSlug}`)).json();
    if (data[0]) {
      return data[0].markets.map(m => ({
        title: m.groupItemTitle,
        price: parseFloat(JSON.parse(m.outcomePrices)[0]),
        volume: parseFloat(m.volume || "0"),
      })).sort((a, b) => b.price - a.price);
    }
  } catch { /* CORS or network error â€” fall through to Supabase */ }

  // Fallback: read latest market prices from Supabase (written by collector)
  try {
    const { data: rows } = await sb
      .from('market_prices')
      .select('bucket, price, volume, collected_at')
      .eq('city', slug)
      .eq('target_date', dateStr)
      .order('collected_at', { ascending: false })
      .limit(50);
    if (!rows || rows.length === 0) return null;
    // Get only the latest collection timestamp's data
    const latestTs = rows[0].collected_at;
    const latest = rows.filter(r => r.collected_at === latestTs);
    return latest.map(r => ({
      title: r.bucket,
      price: r.price,
      volume: r.volume || 0,
    })).sort((a, b) => b.price - a.price);
  } catch { return null; }
}

async function fetchModelTimes(slug, dateStr) {
  try {
    // Fetch recent forecast history per model to find when value last changed
    const { data } = await sb
      .from('forecasts')
      .select('model, temp_value, collected_at')
      .eq('city', slug)
      .eq('target_date', dateStr)
      .order('collected_at', { ascending: false })
      .limit(100);
    if (!data) return {};

    // Group by model, walk backwards to find when the value changed
    const byModel = {};
    data.forEach(r => {
      if (!byModel[r.model]) byModel[r.model] = [];
      byModel[r.model].push(r);
    });

    const times = {};
    for (const [model, rows] of Object.entries(byModel)) {
      if (rows.length === 0) continue;
      const currentVal = rows[0].temp_value;
      // Find the earliest row that still has the current value (= when this value started)
      let changeTime = rows[0].collected_at;
      for (const r of rows) {
        if (Math.abs(r.temp_value - currentVal) < 0.01) {
          changeTime = r.collected_at;
        } else {
          break; // value was different before this point
        }
      }
      times[model] = changeTime;
    }
    return times;
  } catch { return {}; }
}

function getNextModelUpdate(model) {
  // Known schedules (approximate availability on Open-Meteo):
  // ECMWF: 00z ~05:30, 12z ~17:30
  // GFS: 00z ~05:00, 06z ~11:00, 12z ~17:00, 18z ~23:00
  // ICON: 00z ~04:00, 06z ~10:00, 12z ~16:00, 18z ~22:00
  const now = new Date();
  const h = now.getUTCHours();
  const schedules = {
    ecmwf: [{ run: '00z', h: 5, m: 30 }, { run: '12z', h: 17, m: 30 }],
    gfs:   [{ run: '00z', h: 5, m: 0 }, { run: '06z', h: 11, m: 0 }, { run: '12z', h: 17, m: 0 }, { run: '18z', h: 23, m: 0 }],
    icon:  [{ run: '00z', h: 4, m: 0 }, { run: '06z', h: 10, m: 0 }, { run: '12z', h: 16, m: 0 }, { run: '18z', h: 22, m: 0 }],
  };
  const sched = schedules[model];
  if (!sched) return 'â€”';

  const nowMin = h * 60 + now.getUTCMinutes();
  for (const s of sched) {
    const sMin = s.h * 60 + s.m;
    if (sMin > nowMin) {
      const diff = sMin - nowMin;
      if (diff <= 60) return `${s.run} ~${diff}min`;
      return `${s.run} ~${String(s.h).padStart(2,'0')}:${String(s.m).padStart(2,'0')}`;
    }
  }
  // Next is tomorrow's first run
  const first = sched[0];
  return `${first.run} tmrw ~${String(first.h).padStart(2,'0')}:${String(first.m).padStart(2,'0')}`;
}

async function fetchOrderBook(slug, dateStr, bucket) {
  try {
    const fmtDate = formatPolymarketDate(dateStr);
    const eventSlug = `highest-temperature-in-${slug}-on-${fmtDate}`;
    const res = await fetch(`https://gamma-api.polymarket.com/events?slug=${eventSlug}`);
    const data = await res.json();
    if (!data[0]) return null;
    const m = data[0].markets.find(m => m.groupItemTitle === bucket);
    if (!m) return null;
    const tokenId = JSON.parse(m.clobTokenIds)[0];
    const ob = await fetch(`https://clob.polymarket.com/book?token_id=${tokenId}`);
    const book = await ob.json();
    return { asks: book.asks || [], bids: book.bids || [] };
  } catch {
    // CORS likely â€” try Supabase fallback
    return null;
  }
}

function renderCard(city, dateStr, forecasts, market, modelTimes) {
  const u = city.unit === "F" ? "Â°F" : "Â°C";
  const models = Object.entries(forecasts).filter(([k,v]) => v != null);

  // Build model â†’ bucket map
  const modelBuckets = {};
  models.forEach(([k,v]) => modelBuckets[k] = getBucket(v, city.unit));
  const buckets = Object.values(modelBuckets);

  const bucketCounts = {};
  buckets.forEach(b => bucketCounts[b] = (bucketCounts[b] || 0) + 1);
  const consBucket = Object.entries(bucketCounts).sort((a,b) => b[1] - a[1])[0];
  const consensus = consBucket ? consBucket[0] : null;
  const agreement = consBucket ? consBucket[1] : 0;

  // v2 logic: ECMWF must agree + per-city consensus threshold
  const ecmwfBucket = modelBuckets.ecmwf;
  const ecmwfAgrees = ecmwfBucket === consensus;
  const meetsThreshold = agreement >= (city.minConsensus || 2);
  const tradeable = ecmwfAgrees && meetsThreshold;

  // Compute lead days for this card
  const leadDays = Math.max(0, Math.round((new Date(dateStr + 'T12:00:00Z') - new Date()) / 86400000));
  const modelConf = getConf(city, leadDays, agreement);
  const targetMarket = market?.find(m => m.title === consensus);
  const edge = targetMarket && tradeable ? modelConf - targetMarket.price : 0;

  // Signal determination
  let signalClass, signalText;
  if (!ecmwfAgrees && agreement >= 2) {
    signalClass = "signal-skip"; signalText = `â›” ECMWF DISAGREES`;
  } else if (!meetsThreshold) {
    signalClass = "signal-skip"; signalText = agreement < 2 ? `âŒ NO CONSENSUS` : `âŒ NEED ${city.minConsensus}/3 (got ${agreement}/3)`;
  } else if (edge > 0.15) {
    signalClass = "signal-strong"; signalText = `ğŸ”¥ STRONG (${agreement}/3)`;
  } else if (edge > 0.05) {
    signalClass = "signal-marginal"; signalText = `âš ï¸ MARGINAL (${agreement}/3)`;
  } else {
    signalClass = "signal-skip"; signalText = `âŒ NO EDGE`;
  }

  const now = new Date();
  const ts = now.toLocaleString('en-GB', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'UTC' }) + ' UTC';
  const marketOdds = targetMarket ? `${(targetMarket.price*100).toFixed(1)}Â¢` : 'â€”';
  const topMarket = market?.[0];
  const topOdds = topMarket ? `${topMarket.title} @ ${(topMarket.price*100).toFixed(1)}Â¢` : '';
  const tierBadge = city.tier === 'primary'
    ? `<span style="background:#0f3d0f;color:#4ade80;padding:1px 6px;border-radius:4px;font-size:0.7em;margin-left:6px">PRIMARY</span>`
    : `<span style="background:#1e1e2e;color:#888;padding:1px 6px;border-radius:4px;font-size:0.7em;margin-left:6px">${city.minConsensus}/3 REQ</span>`;

  let html = `<div class="card">
    <div class="card-header"><span class="city-name">${city.flag || ''} ${city.name}${tierBadge}</span><span class="date-badge">${dateStr}</span></div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
      <span class="signal ${signalClass}" style="margin-bottom:0">${signalText}</span>
      <span style="font-size:0.7em;color:#555">ğŸ• ${ts}</span>
    </div>
    <div style="display:flex;gap:12px;margin-bottom:10px;padding:8px;background:#0a0a12;border-radius:8px;font-size:0.85em">
      <div style="flex:1"><span style="color:#666;font-size:0.8em">CONSENSUS</span><div style="font-weight:700;color:${tradeable?'#4ade80':'#555'}">${consensus || 'None'}</div></div>
      <div style="flex:1"><span style="color:#666;font-size:0.8em">MARKET ODDS</span><div style="font-weight:700;color:#60a5fa">${tradeable ? marketOdds : 'â€”'}</div></div>
      <div style="flex:1"><span style="color:#666;font-size:0.8em">FAVORITE</span><div style="font-weight:700;color:#facc15">${topOdds || 'â€”'}</div></div>
    </div>
    <div class="models">`;
  for (const [model, val] of models) {
    const bucket = getBucket(val, city.unit);
    const isCons = bucket === consensus;
    const isEcmwf = model === 'ecmwf';
    const border = isEcmwf ? 'border:1px solid #4ade8044;' : '';
    const mTime = (modelTimes || {})[model];
    const mTimeStr = mTime ? new Date(mTime).toLocaleString('en-GB', { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', hour12:false, timeZone:'UTC' }) : '';
    const nextUpdate = getNextModelUpdate(model);
    html += `<div class="model-box" style="${border}"><div class="model-name">${model}${isEcmwf ? ' â˜…' : ''}</div><div class="model-val ${isCons?'agree':'disagree'}">${val.toFixed(1)}${u}</div><div class="model-bucket ${isCons?'agree':'disagree'}">â†’ ${bucket}</div>${mTimeStr ? '<div style="font-size:0.6em;color:#444;margin-top:3px">Î” '+mTimeStr+'</div>' : ''}<div style="font-size:0.6em;color:#333;margin-top:1px">next: ${nextUpdate}</div></div>`;
  }
  html += `</div>`;

  // ECMWF check banner
  if (!ecmwfAgrees && agreement >= 2) {
    html += `<div style="background:#2d1215;border:1px solid #7f1d1d;border-radius:6px;padding:8px;margin-bottom:8px;font-size:0.8em;color:#f87171">â›” ECMWF forecasts <strong>${ecmwfBucket}${u}</strong> but consensus is <strong>${consensus}${u}</strong> â€” trade blocked per v2 rules</div>`;
  }

  if (market) {
    html += `<div style="font-size:0.75em;color:#555;margin-bottom:4px">MARKET PRICES</div>`;
    for (const m of market.slice(0, 5)) {
      const isTarget = targetMarket && m.title === targetMarket.title;
      const barColor = isTarget ? (edge > 0.15 ? 'bar-green' : edge > 0 ? 'bar-yellow' : 'bar-gray') : 'bar-gray';
      html += `<div class="market-row ${isTarget ? 'target' : ''}"><span>${m.title}</span><div style="display:flex;align-items:center;gap:8px"><div class="bar-container"><div class="bar ${barColor}" style="width:${m.price*100}%"></div></div><span style="width:40px;text-align:right">${(m.price*100).toFixed(1)}%</span></div></div>`;
    }
  } else {
    html += `<div style="color:#555;font-size:0.85em">No market found</div>`;
  }

  if (targetMarket && tradeable) {
    html += `<div class="edge-box"><div><div class="edge-label">TARGET</div><div>${targetMarket.title} @ ${(targetMarket.price*100).toFixed(1)}Â¢</div></div><div><div class="edge-label">CONF (D+${leadDays}, ${agreement}/3)</div><div>${(modelConf*100).toFixed(0)}%</div></div><div><div class="edge-label">EDGE</div><div class="edge-value ${edge > 0 ? 'edge-positive' : 'edge-negative'}">${edge > 0 ? '+' : ''}${(edge*100).toFixed(1)}%</div></div></div>`;

    // Mark for depth loading after render
    html += `<div class="depth-slot" data-city="${city.slug}" data-date="${dateStr}" data-conf="${modelConf}" style="margin-top:8px;font-size:0.8em;color:#444">Loading depth...</div>`;
  }
  html += `</div>`;
  return { html, signal: signalClass.includes("strong") ? "strong" : signalClass.includes("marginal") ? "marginal" : "skip", edge };
}

async function refresh() {
  const dashboard = document.getElementById("dashboard");
  dashboard.innerHTML = '<div class="card"><div class="loading">Fetching live data...</div></div>';

  const dates = getDates();
  let cards = [];
  let strong = 0, marginal = 0, bestEdge = 0;

  for (const dateStr of dates) {
    for (const city of CITIES) {
      try {
        const [forecasts, market, modelTimes] = await Promise.all([
          fetchForecastsLive(city.slug, city.unit, dateStr),
          fetchMarketLive(city.slug, dateStr),
          fetchModelTimes(city.slug, dateStr),
        ]);
        const result = renderCard(city, dateStr, forecasts, market, modelTimes);
        cards.push(result);
        if (result.signal === "strong") strong++;
        if (result.signal === "marginal") marginal++;
        if (result.edge > bestEdge) bestEdge = result.edge;
      } catch (e) {
        cards.push({ html: `<div class="card"><div class="city-name">${city.name} â€” ${dateStr}</div><div style="color:#f87171">${e.message}</div></div>`, signal: "skip", edge: 0 });
      }
    }
  }

  const order = { strong: 0, marginal: 1, skip: 2 };
  cards.sort((a, b) => order[a.signal] - order[b.signal]);
  dashboard.innerHTML = cards.map(c => c.html).join("");

  document.getElementById("signalCount").textContent = cards.length;
  document.getElementById("strongCount").textContent = strong;
  document.getElementById("marginalCount").textContent = marginal;
  document.getElementById("bestEdge").textContent = bestEdge > 0 ? `+${(bestEdge*100).toFixed(0)}%` : "â€”";
  document.getElementById("lastUpdate").textContent = `| Updated ${new Date().toLocaleTimeString()}`;

  // Check data points in supabase
  const { count } = await sb.from('forecasts').select('*', { count: 'exact', head: true });
  document.getElementById("dataPoints").textContent = count ?? 0;
}

// Extract temperature from bucket label: "8Â°C" -> 8, "52 to 53Â°F" -> 52.5
function bucketToTemp(bucket) {
  if (!bucket) return null;
  const cMatch = bucket.match(/^(-?\d+)Â°C$/);
  if (cMatch) return parseInt(cMatch[1]);
  const fMatch = bucket.match(/^(-?\d+)\s*to\s*(-?\d+)Â°F$/);
  if (fMatch) return (parseInt(fMatch[1]) + parseInt(fMatch[2])) / 2;
  return null;
}

async function loadCharts() {
  const area = document.getElementById("chartArea");
  area.innerHTML = '<div class="loading" style="padding:40px;text-align:center">Loading historical data...</div>';

  const dates = getDates();
  let html = '';

  for (const city of CITIES) {
    html += `<div class="chart-container">
      <div class="chart-header">
        <span class="chart-title">${city.name} â€” Forecast vs Market Favorite</span>
        <div class="date-selector" id="dates-${city.slug}">
          ${dates.map((d, i) => `<button class="date-btn ${i===1?'active':''}" onclick="loadCityChart('${city.slug}','${d}',this)">${d}</button>`).join('')}
        </div>
      </div>
      <div class="chart-wrap"><canvas id="chart-${city.slug}"></canvas></div>
    </div>`;
  }
  area.innerHTML = html;

  for (const city of CITIES) {
    await loadCityChart(city.slug, dates[1]);
  }
}

async function loadCityChart(slug, targetDate, btn) {
  if (btn) {
    btn.parentElement.querySelectorAll('.date-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  }

  const city = CITIES.find(c => c.slug === slug);
  const unit = city.unit === "F" ? "Â°F" : "Â°C";
  const canvasId = `chart-${slug}`;

  // Fetch ECMWF forecasts over time from Supabase
  const { data: fcRows } = await sb
    .from('forecasts')
    .select('model, temp_value, collected_at')
    .eq('city', slug)
    .eq('target_date', targetDate)
    .eq('model', 'ecmwf')
    .order('collected_at', { ascending: true });

  // Fetch market prices over time â€” we need the favorite (highest priced bucket) at each collection
  const { data: mkRows } = await sb
    .from('market_prices')
    .select('bucket, price, collected_at')
    .eq('city', slug)
    .eq('target_date', targetDate)
    .order('collected_at', { ascending: true });

  if (charts[canvasId]) { charts[canvasId].destroy(); delete charts[canvasId]; }

  const canvas = document.getElementById(canvasId);
  if (!canvas) return;

  if ((!fcRows || fcRows.length === 0) && (!mkRows || mkRows.length === 0)) {
    canvas.parentElement.innerHTML = `<div class="no-data">No historical data yet for ${targetDate}. Collector needs to run first.</div>`;
    return;
  }

  // ECMWF forecast temp over time
  const forecastData = (fcRows || []).map(r => ({
    x: new Date(r.collected_at),
    y: r.temp_value
  }));

  // Market favorite: group by collected_at, pick highest-priced bucket, extract its temp
  const byTime = {};
  (mkRows || []).forEach(r => {
    const t = r.collected_at;
    if (!byTime[t] || r.price > byTime[t].price) {
      byTime[t] = { bucket: r.bucket, price: r.price };
    }
  });
  const favoriteData = Object.entries(byTime)
    .map(([t, v]) => ({ x: new Date(t), y: bucketToTemp(v.bucket) }))
    .filter(d => d.y != null);

  const datasets = [
    {
      label: 'ECMWF Forecast',
      data: forecastData,
      borderColor: '#4ade80',
      backgroundColor: 'rgba(74,222,128,0.1)',
      borderWidth: 2.5,
      pointRadius: 4,
      pointBackgroundColor: '#4ade80',
      fill: false,
      tension: 0.3,
    },
    {
      label: 'Market Favorite',
      data: favoriteData,
      borderColor: '#60a5fa',
      backgroundColor: 'rgba(96,165,250,0.1)',
      borderWidth: 2.5,
      pointRadius: 4,
      pointBackgroundColor: '#60a5fa',
      pointStyle: 'rectRot',
      fill: false,
      tension: 0.3,
    },
  ];

  // Add shaded area between the two lines if they diverge
  if (forecastData.length > 0 && favoriteData.length > 0) {
    // Determine y-axis range
    const allY = [...forecastData.map(d => d.y), ...favoriteData.map(d => d.y)];
    var yMin = Math.floor(Math.min(...allY) - 2);
    var yMax = Math.ceil(Math.max(...allY) + 2);
  }

  charts[canvasId] = new Chart(canvas, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { labels: { color: '#888', font: { size: 11 } } },
        tooltip: {
          backgroundColor: '#1e1e2e',
          titleColor: '#fff',
          bodyColor: '#ccc',
          borderColor: '#2e2e3e',
          borderWidth: 1,
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}${unit}`
          }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: { tooltipFormat: 'MMM d, HH:mm', displayFormats: { hour: 'HH:mm', day: 'MMM d' } },
          title: { display: true, text: 'Time (UTC)', color: '#666' },
          ticks: { color: '#555' },
          grid: { color: '#1a1a2a' },
        },
        y: {
          position: 'left',
          min: yMin ?? undefined,
          max: yMax ?? undefined,
          title: { display: true, text: `Temperature (${unit})`, color: '#666' },
          ticks: { color: '#555', callback: v => v + unit },
          grid: { color: '#1a1a2a' },
        }
      }
    }
  });
}

async function loadTrades() {
  const area = document.getElementById("tradesArea");
  const stats = document.getElementById("tradesStats");
  area.innerHTML = '<div class="card"><div class="loading">Loading trades...</div></div>';

  const { data: trades, error } = await sb
    .from('trades')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(100);

  if (error || !trades) {
    area.innerHTML = '<div class="card"><div style="color:#f87171">Error loading trades</div></div>';
    return;
  }

  if (trades.length === 0) {
    stats.innerHTML = '';
    area.innerHTML = '<div class="card"><div class="no-data">No trades yet. Bot will auto-trade on strong signals when POLY_ENABLED=true.</div></div>';
    return;
  }

  // Fetch current market prices for open trades
  const openTrades = trades.filter(t => t.status === 'open');
  const currentPrices = {};
  for (const t of openTrades) {
    const key = `${t.city}:${t.target_date}`;
    if (currentPrices[key]) continue;
    const market = await fetchMarketLive(t.city, t.target_date);
    if (market) {
      currentPrices[key] = {};
      market.forEach(m => currentPrices[key][m.title] = m.price);
    }
  }

  // Attach current price + unrealized P&L to each trade
  for (const t of trades) {
    if (t.status === 'open') {
      const key = `${t.city}:${t.target_date}`;
      t._currentPrice = currentPrices[key]?.[t.bucket] ?? null;
      t._unrealizedPnl = t._currentPrice != null ? +((t._currentPrice - t.price) * t.shares).toFixed(2) : null;
    } else {
      t._currentPrice = null;
      t._unrealizedPnl = null;
    }
  }

  // Compute stats
  const totalCost = trades.reduce((s, t) => s + (t.cost || 0), 0);
  const wins = trades.filter(t => t.status === 'won');
  const losses = trades.filter(t => t.status === 'lost');
  const open = openTrades;
  const realizedPnl = trades.reduce((s, t) => s + (t.pnl || 0), 0);
  const unrealizedPnl = trades.reduce((s, t) => s + (t._unrealizedPnl || 0), 0);
  const totalPnl = realizedPnl + unrealizedPnl;
  const winRate = (wins.length + losses.length) > 0 ? (wins.length / (wins.length + losses.length) * 100).toFixed(0) : 'â€”';

  stats.innerHTML = `
    <div class="stat"><div class="stat-label">Total Trades</div><div class="stat-value">${trades.length}</div></div>
    <div class="stat"><div class="stat-label">Open</div><div class="stat-value" style="color:#60a5fa">${open.length}</div></div>
    <div class="stat"><div class="stat-label">Won</div><div class="stat-value edge-positive">${wins.length}</div></div>
    <div class="stat"><div class="stat-label">Lost</div><div class="stat-value edge-negative">${losses.length}</div></div>
    <div class="stat"><div class="stat-label">Win Rate</div><div class="stat-value" style="color:#facc15">${winRate}%</div></div>
    <div class="stat"><div class="stat-label">Deployed</div><div class="stat-value">$${totalCost.toFixed(2)}</div></div>
    <div class="stat"><div class="stat-label">Realized</div><div class="stat-value ${realizedPnl >= 0 ? 'edge-positive' : 'edge-negative'}">${realizedPnl >= 0 ? '+' : ''}$${realizedPnl.toFixed(2)}</div></div>
    <div class="stat"><div class="stat-label">Unrealized</div><div class="stat-value ${unrealizedPnl >= 0 ? 'edge-positive' : 'edge-negative'}">${unrealizedPnl >= 0 ? '+' : ''}$${unrealizedPnl.toFixed(2)}</div></div>
    <div class="stat"><div class="stat-label">Total P&L</div><div class="stat-value ${totalPnl >= 0 ? 'edge-positive' : 'edge-negative'}">${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}</div></div>
  `;

  // Render trade rows
  let html = `<div class="card" style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:0.85em">
    <thead><tr style="border-bottom:1px solid #2e2e3e;text-align:left">
      <th style="padding:8px;color:#666">Time</th>
      <th style="padding:8px;color:#666">City</th>
      <th style="padding:8px;color:#666">Date</th>
      <th style="padding:8px;color:#666">Bucket</th>
      <th style="padding:8px;color:#666">Entry</th>
      <th style="padding:8px;color:#666">Now</th>
      <th style="padding:8px;color:#666">Shares</th>
      <th style="padding:8px;color:#666">Cost</th>
      <th style="padding:8px;color:#666">Edge</th>
      <th style="padding:8px;color:#666">Status</th>
      <th style="padding:8px;color:#666">P&L</th>
    </tr></thead><tbody>`;

  for (const t of trades) {
    const time = new Date(t.created_at).toLocaleString('en-GB', { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', hour12:false, timeZone:'UTC' });
    const cityName = CITIES.find(c => c.slug === t.city)?.name || t.city;
    const statusColor = t.status === 'won' ? '#4ade80' : t.status === 'lost' ? '#f87171' : '#60a5fa';
    const statusIcon = t.status === 'won' ? 'âœ…' : t.status === 'lost' ? 'âŒ' : 'â³';
    // P&L: use realized for resolved trades, unrealized for open
    const displayPnl = t.pnl != null ? t.pnl : t._unrealizedPnl;
    const pnl = displayPnl != null ? `${displayPnl >= 0 ? '+' : ''}$${displayPnl.toFixed(2)}` : 'â€”';
    const pnlColor = displayPnl != null ? (displayPnl >= 0 ? '#4ade80' : '#f87171') : '#555';

    // Current price
    const currentPrice = t._currentPrice != null ? `${(t._currentPrice*100).toFixed(1)}Â¢` : 'â€”';
    const priceChange = t._currentPrice != null ? t._currentPrice - t.price : null;
    const nowColor = priceChange != null ? (priceChange >= 0 ? '#4ade80' : '#f87171') : '#555';

    html += `<tr style="border-bottom:1px solid #1a1a2a">
      <td style="padding:8px;color:#888">${time}</td>
      <td style="padding:8px;font-weight:600">${cityName}</td>
      <td style="padding:8px;color:#888">${t.target_date}</td>
      <td style="padding:8px"><span style="background:#1e1e2e;padding:2px 8px;border-radius:4px">${t.bucket}</span></td>
      <td style="padding:8px">${(t.price*100).toFixed(1)}Â¢</td>
      <td style="padding:8px;color:${nowColor};font-weight:600">${currentPrice}</td>
      <td style="padding:8px">${t.shares?.toFixed(1)}</td>
      <td style="padding:8px">$${t.cost?.toFixed(2)}</td>
      <td style="padding:8px;color:${t.edge > 0.15 ? '#4ade80' : '#facc15'}">${t.edge != null ? '+' + (t.edge*100).toFixed(0) + '%' : 'â€”'}</td>
      <td style="padding:8px;color:${statusColor}">${statusIcon} ${t.status}</td>
      <td style="padding:8px;color:${pnlColor};font-weight:600">${pnl}</td>
    </tr>`;
  }

  html += '</tbody></table></div>';

  // Load alerts for open trades
  const openIds = trades.filter(t => t.status === 'open').map(t => t.id);
  if (openIds.length > 0) {
    const { data: alerts } = await sb
      .from('trade_alerts')
      .select('*')
      .in('trade_id', openIds)
      .order('created_at', { ascending: false })
      .limit(50);

    if (alerts && alerts.length > 0) {
      // Group by trade, show latest per trade
      const latestByTrade = {};
      alerts.forEach(a => { if (!latestByTrade[a.trade_id]) latestByTrade[a.trade_id] = a; });

      html += '<div style="margin-top:16px"><div style="font-size:0.75em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">ğŸ“¡ Forecast Monitor</div>';
      for (const a of Object.values(latestByTrade)) {
        const cityName = CITIES.find(c => c.slug === a.city)?.name || a.city;
        const time = new Date(a.created_at).toLocaleString('en-GB', { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', hour12:false, timeZone:'UTC' });
        const stateColor = a.state === 'holding' ? '#4ade80' : a.state === 'drifting' ? '#facc15' : '#f87171';
        const stateBg = a.state === 'holding' ? '#0f3d0f' : a.state === 'drifting' ? '#3d3d0f' : '#3d0f0f';
        html += `<div class="card" style="margin-bottom:8px;padding:12px;border-left:3px solid ${stateColor}">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>${cityName}</strong> ${a.target_date} â€” <span style="background:${stateBg};color:${stateColor};padding:2px 8px;border-radius:4px;font-size:0.8em">${a.state.toUpperCase()}</span></div>
            <span style="font-size:0.7em;color:#555">${time} UTC</span>
          </div>
          <div style="margin-top:6px;font-size:0.85em;color:#aaa">${a.detail}</div>
          <div style="margin-top:4px;font-size:0.75em;color:#555">${a.model_detail}</div>
        </div>`;
      }
      html += '</div>';
    }
  }

  area.innerHTML = html;
}

let backtestCharts = {};

async function renderRealisticPnl() {
  // Check if we have price history data
  const { count } = await sb.from('price_history').select('*', { count: 'exact', head: true });
  if (!count || count === 0) return '<div class="card" style="margin-top:16px"><div class="no-data">No historical price data. Run the price scraper first.</div></div>';

  let html = `<div style="margin-top:16px">
    <div style="font-size:0.8em;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #1e1e2e">ğŸ’° Realistic Entry Prices (from Polymarket CLOB)</div>`;

  const cityConfigs = [
    { slug: 'london', name: 'London', color: '#4ade80', conf: 0.83, minCons: 1 },  // D+0 â‰¥2/3 conf
    { slug: 'paris', name: 'Paris', color: '#60a5fa', conf: 0.66, minCons: 3 },   // D+0 â‰¥2/3 conf (real)
    { slug: 'chicago', name: 'Chicago', color: '#facc15', conf: 0.66, minCons: 3 }, // D+0 â‰¥2/3 conf (real)
  ];

  const allCityData = [];

  for (const city of cityConfigs) {
    // Get distinct target dates with price data
    const { data: dateRows } = await sb.from('price_history')
      .select('target_date')
      .eq('city', city.slug)
      .order('target_date');
    if (!dateRows || dateRows.length === 0) continue;
    const dates = [...new Set(dateRows.map(r => r.target_date))];

    const entries = [];

    for (const td of dates) {
      // Find winning bucket (highest final price)
      const { data: latest } = await sb.from('price_history')
        .select('bucket, price')
        .eq('city', city.slug).eq('target_date', td)
        .order('timestamp', { ascending: false })
        .limit(20);
      if (!latest) continue;

      const byBucket = {};
      latest.forEach(p => { if (!byBucket[p.bucket]) byBucket[p.bucket] = p; });
      const winner = Object.entries(byBucket).sort((a,b) => b[1].price - a[1].price)[0];
      if (!winner || winner[1].price < 0.8) continue;
      const winBucket = winner[0];

      // Get price history for winning bucket
      const { data: hist } = await sb.from('price_history')
        .select('price, timestamp')
        .eq('city', city.slug).eq('target_date', td).eq('bucket', winBucket)
        .order('timestamp');
      if (!hist || hist.length < 3) continue;

      // Find D-1 prices at 06:00, 11:00, 18:00
      const tDate = new Date(td + 'T00:00:00Z');
      const dMinus1 = new Date(tDate); dMinus1.setUTCDate(dMinus1.getUTCDate() - 1);
      const dm1 = dMinus1.toISOString().slice(0,10);

      const findPrice = (hour) => {
        const target = new Date(dm1 + 'T' + String(hour).padStart(2,'0') + ':00:00Z');
        let best = null, bestDist = Infinity;
        for (const p of hist) {
          const d = Math.abs(new Date(p.timestamp) - target);
          if (d < bestDist) { bestDist = d; best = p; }
        }
        return (best && bestDist < 3*3600000) ? best.price : null;
      };

      entries.push({ date: td, bucket: winBucket, p06: findPrice(6), p11: findPrice(11), p18: findPrice(18) });
    }

    if (entries.length === 0) continue;

    const valid06 = entries.filter(e => e.p06 != null);
    const valid11 = entries.filter(e => e.p11 != null);
    const valid18 = entries.filter(e => e.p18 != null);
    const avg06 = valid06.length ? valid06.reduce((s,e) => s + e.p06, 0) / valid06.length : 0;
    const avg11 = valid11.length ? valid11.reduce((s,e) => s + e.p11, 0) / valid11.length : 0;
    const avg18 = valid18.length ? valid18.reduce((s,e) => s + e.p18, 0) / valid18.length : 0;

    // Simulate realistic P&L with consensus win rate
    const betSize = 20;
    const simTrades = valid06.length;
    const simWins = Math.round(simTrades * city.conf);
    const simLosses = simTrades - simWins;
    const avgWinProfit = valid06.length ? valid06.reduce((s,e) => s + (Math.floor(betSize/e.p06) * (1 - e.p06)), 0) / valid06.length : 0;
    const simPnl = (simWins * avgWinProfit) - (simLosses * betSize);

    allCityData.push({ ...city, entries, avg06, avg11, avg18, simTrades, simWins, simLosses, simPnl, avgWinProfit });
  }

  // Summary cards
  html += '<div class="grid">';
  for (const c of allCityData) {
    const roi = c.simPnl / (c.simTrades * 20) * 100;
    html += `<div class="card" style="border-left:3px solid ${c.color}">
      <div style="font-weight:700;margin-bottom:8px">${c.name} <span style="color:#555;font-size:0.8em">(${c.entries.length} markets)</span></div>
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-bottom:10px">
        <div style="background:#0a0a12;border-radius:6px;padding:8px;text-align:center">
          <div style="font-size:0.65em;color:#666">@06:00</div>
          <div style="font-size:1.2em;font-weight:700;color:#4ade80">${(c.avg06*100).toFixed(1)}Â¢</div>
          <div style="font-size:0.6em;color:#555">post-00z</div>
        </div>
        <div style="background:#0a0a12;border-radius:6px;padding:8px;text-align:center">
          <div style="font-size:0.65em;color:#666">@11:00</div>
          <div style="font-size:1.2em;font-weight:700;color:#facc15">${(c.avg11*100).toFixed(1)}Â¢</div>
          <div style="font-size:0.6em;color:#555">mkt open</div>
        </div>
        <div style="background:#0a0a12;border-radius:6px;padding:8px;text-align:center">
          <div style="font-size:0.65em;color:#666">@18:00</div>
          <div style="font-size:1.2em;font-weight:700;color:#f87171">${(c.avg18*100).toFixed(1)}Â¢</div>
          <div style="font-size:0.6em;color:#555">post-12z</div>
        </div>
      </div>
      <div style="background:#0a0a12;border-radius:8px;padding:10px;display:flex;justify-content:space-between">
        <div><div style="font-size:0.65em;color:#666">SIM P&L ($20/trade)</div><div style="font-size:1.3em;font-weight:700;color:${c.simPnl >= 0 ? '#4ade80' : '#f87171'}">${c.simPnl >= 0 ? '+' : ''}$${c.simPnl.toFixed(0)}</div></div>
        <div><div style="font-size:0.65em;color:#666">WIN RATE</div><div style="font-size:1.3em;font-weight:700;color:${c.color}">${(c.conf*100).toFixed(0)}%</div></div>
        <div><div style="font-size:0.65em;color:#666">ROI</div><div style="font-size:1.3em;font-weight:700;color:${roi > 0 ? '#4ade80' : '#f87171'}">${roi >= 0 ? '+' : ''}${roi.toFixed(0)}%</div></div>
      </div>
    </div>`;
  }
  html += '</div>';

  // Entry time comparison table
  html += `<div class="card" style="margin-top:12px">
    <div style="font-size:0.75em;color:#555;margin-bottom:6px">WINNING BUCKET PRICE BY ENTRY TIME (D-1)</div>
    <table style="width:100%;border-collapse:collapse;font-size:0.8em">
      <thead><tr style="border-bottom:1px solid #2e2e3e;text-align:left">
        <th style="padding:6px;color:#666">City</th><th style="padding:6px;color:#666">Date</th><th style="padding:6px;color:#666">Winner</th>
        <th style="padding:6px;color:#4ade80">@06:00</th><th style="padding:6px;color:#facc15">@11:00</th><th style="padding:6px;color:#f87171">@18:00</th>
        <th style="padding:6px;color:#666">Spread</th>
      </tr></thead><tbody>`;

  for (const c of allCityData) {
    for (const e of c.entries) {
      const fmt = p => p != null ? `${(p*100).toFixed(1)}Â¢` : 'â€”';
      const spread = (e.p06 != null && e.p18 != null) ? `${((e.p18 - e.p06)*100).toFixed(1)}Â¢` : 'â€”';
      const spreadColor = (e.p18 != null && e.p06 != null && e.p18 > e.p06) ? '#f87171' : '#4ade80';
      html += `<tr style="border-bottom:1px solid #1a1a2a">
        <td style="padding:6px;color:${c.color}">${c.name}</td>
        <td style="padding:6px;color:#888">${e.date}</td>
        <td style="padding:6px"><span style="background:#1e1e2e;padding:2px 6px;border-radius:4px">${e.bucket}</span></td>
        <td style="padding:6px;color:#4ade80;font-weight:600">${fmt(e.p06)}</td>
        <td style="padding:6px;color:#facc15">${fmt(e.p11)}</td>
        <td style="padding:6px;color:#f87171">${fmt(e.p18)}</td>
        <td style="padding:6px;color:${spreadColor}">${spread}</td>
      </tr>`;
    }
  }
  html += '</tbody></table></div>';

  html += `<div style="font-size:0.75em;color:#444;margin-top:6px;font-style:italic">Based on ${count.toLocaleString()} historical price points from Polymarket CLOB API. Sim uses per-city consensus win rates. 06:00 UTC = cheapest avg entry (right after ECMWF 00z drop).</div>`;
  html += '</div>';
  return html;
}

async function loadBacktest(runId) {
  const area = document.getElementById("backtestArea");
  area.innerHTML = '<div class="card"><div class="loading">Loading backtest data...</div></div>';

  // Get available runs
  const { data: summaries } = await sb
    .from('backtest_summary')
    .select('*')
    .order('created_at', { ascending: false });

  if (!summaries || summaries.length === 0) {
    area.innerHTML = '<div class="card"><div class="no-data">No backtest data yet. Run the backtest script first.</div></div>';
    return;
  }

  // Get unique run IDs
  const runs = [...new Set(summaries.map(s => s.run_id))];
  const selectedRun = runId || runs[0];
  const runSummaries = summaries.filter(s => s.run_id === selectedRun);

  // Fetch daily results for this run
  const { data: results } = await sb
    .from('backtest_results')
    .select('*')
    .eq('run_id', selectedRun)
    .order('target_date', { ascending: true });

  let html = '';

  // Run selector
  html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
    <div style="font-size:1.1em;font-weight:600">Backtest: ${selectedRun}</div>
    <select onchange="loadBacktest(this.value)" style="background:#1e1e2e;color:#e0e0e0;border:1px solid #2e2e3e;padding:6px 12px;border-radius:8px;font-size:0.85em">
      ${runs.map(r => `<option value="${r}" ${r===selectedRun?'selected':''}>${r}</option>`).join('')}
    </select>
  </div>`;

  // Summary cards
  html += '<div class="grid">';
  const cityColors = { paris: '#60a5fa', london: '#4ade80', chicago: '#facc15', 'buenos-aires': '#fb923c' };

  for (const s of runSummaries) {
    const cityName = CITIES.find(c => c.slug === s.city)?.name || s.city;
    const col = cityColors[s.city] || '#888';

    html += `<div class="card">
      <div class="card-header">
        <span class="city-name" style="border-left:3px solid ${col};padding-left:8px">${cityName}</span>
        <span class="date-badge">${s.days} days</span>
      </div>

      <div style="display:flex;gap:8px;margin-bottom:12px">
        <div style="flex:1;background:#0a0a12;border-radius:8px;padding:10px;text-align:center">
          <div style="font-size:0.7em;color:#666;text-transform:uppercase">â‰¥2/3 Consensus</div>
          <div style="font-size:1.6em;font-weight:700;color:${s.consensus2_rate > 0.75 ? '#4ade80' : s.consensus2_rate > 0.6 ? '#facc15' : '#f87171'}">${(s.consensus2_rate*100).toFixed(0)}%</div>
          <div style="font-size:0.75em;color:#555">${s.consensus2_correct}/${s.consensus2_total}</div>
        </div>
        <div style="flex:1;background:#0a0a12;border-radius:8px;padding:10px;text-align:center">
          <div style="font-size:0.7em;color:#666;text-transform:uppercase">3/3 Consensus</div>
          <div style="font-size:1.6em;font-weight:700;color:${s.consensus3_rate > 0.8 ? '#4ade80' : s.consensus3_rate > 0.65 ? '#facc15' : '#f87171'}">${s.consensus3_total > 0 ? (s.consensus3_rate*100).toFixed(0) : 'â€”'}%</div>
          <div style="font-size:0.75em;color:#555">${s.consensus3_correct}/${s.consensus3_total}</div>
        </div>
      </div>

      <div style="font-size:0.75em;color:#555;margin-bottom:6px">MODEL ACCURACY</div>
      ${renderModelBar('ECMWF', s.ecmwf_match_rate, s.ecmwf_mae, '#4ade80')}
      ${renderModelBar('GFS', s.gfs_match_rate, s.gfs_mae, '#60a5fa')}
      ${renderModelBar('ICON', s.icon_match_rate, s.icon_mae, '#facc15')}
    </div>`;
  }
  html += '</div>';

  // Charts section
  html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:16px">
    <div class="chart-container">
      <div class="chart-title" style="margin-bottom:12px">Model Accuracy by City</div>
      <div style="height:280px"><canvas id="bt-accuracy-chart"></canvas></div>
    </div>
    <div class="chart-container">
      <div class="chart-title" style="margin-bottom:12px">Monthly Consensus Accuracy</div>
      <div style="height:280px"><canvas id="bt-monthly-chart"></canvas></div>
    </div>
  </div>`;

  // Realistic P&L from historical price data
  html += await renderRealisticPnl();

  // Daily results table
  html += `<div class="card" style="margin-top:16px;overflow-x:auto">
    <div style="font-size:0.75em;color:#555;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">Daily Results (${results?.length || 0} days)</div>
    <div style="max-height:500px;overflow-y:auto">
    <table style="width:100%;border-collapse:collapse;font-size:0.8em">
      <thead style="position:sticky;top:0;background:#13131a"><tr style="border-bottom:1px solid #2e2e3e;text-align:left">
        <th style="padding:6px;color:#666">Date</th>
        <th style="padding:6px;color:#666">City</th>
        <th style="padding:6px;color:#666">Actual</th>
        <th style="padding:6px;color:#666">ECMWF</th>
        <th style="padding:6px;color:#666">GFS</th>
        <th style="padding:6px;color:#666">ICON</th>
        <th style="padding:6px;color:#666">Consensus</th>
        <th style="padding:6px;color:#666">Result</th>
      </tr></thead><tbody>`;

  for (const r of (results || []).reverse()) {
    const cityName = CITIES.find(c => c.slug === r.city)?.name || r.city;
    const ecmwfColor = r.ecmwf_match ? '#4ade80' : '#f87171';
    const gfsColor = r.gfs_match ? '#4ade80' : '#f87171';
    const iconColor = r.icon_match ? '#4ade80' : '#f87171';
    const consColor = r.consensus_correct ? '#4ade80' : '#f87171';
    const consIcon = r.consensus_correct ? 'âœ…' : 'âŒ';

    html += `<tr style="border-bottom:1px solid #1a1a2a">
      <td style="padding:6px;color:#888">${r.target_date}</td>
      <td style="padding:6px">${cityName}</td>
      <td style="padding:6px;font-weight:600">${r.actual_temp?.toFixed(1)} â†’ ${r.actual_bucket}</td>
      <td style="padding:6px;color:${ecmwfColor}">${r.ecmwf_temp?.toFixed(1)} â†’ ${r.ecmwf_bucket}</td>
      <td style="padding:6px;color:${gfsColor}">${r.gfs_temp?.toFixed(1)} â†’ ${r.gfs_bucket}</td>
      <td style="padding:6px;color:${iconColor}">${r.icon_temp?.toFixed(1)} â†’ ${r.icon_bucket}</td>
      <td style="padding:6px"><span style="background:${r.consensus_count >= 3 ? '#0f3d0f' : r.consensus_count >= 2 ? '#3d3d0f' : '#2d1215'};color:${r.consensus_count >= 3 ? '#4ade80' : r.consensus_count >= 2 ? '#facc15' : '#f87171'};padding:2px 8px;border-radius:4px">${r.consensus_bucket} (${r.consensus_count}/3)</span></td>
      <td style="padding:6px;color:${consColor}">${consIcon}</td>
    </tr>`;
  }
  html += '</tbody></table></div></div>';

  area.innerHTML = html;

  // Render charts
  renderAccuracyChart(runSummaries);
  renderMonthlyChart(results || []);
}

function renderModelBar(name, rate, mae, color) {
  const pct = rate != null ? (rate * 100).toFixed(0) : 0;
  const maeStr = mae != null ? mae.toFixed(2) : 'â€”';
  return `<div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
    <span style="width:50px;font-size:0.8em;color:#888">${name}</span>
    <div style="flex:1;height:8px;background:#1a1a2a;border-radius:4px;overflow:hidden">
      <div style="height:100%;width:${pct}%;background:${color};border-radius:4px;transition:width 0.5s"></div>
    </div>
    <span style="width:35px;font-size:0.8em;color:${color};text-align:right;font-weight:600">${pct}%</span>
    <span style="width:50px;font-size:0.7em;color:#555;text-align:right">MAE ${maeStr}</span>
  </div>`;
}

function renderAccuracyChart(summaries) {
  if (backtestCharts['accuracy']) backtestCharts['accuracy'].destroy();
  const canvas = document.getElementById('bt-accuracy-chart');
  if (!canvas) return;

  const cities = summaries.map(s => CITIES.find(c => c.slug === s.city)?.name || s.city);
  backtestCharts['accuracy'] = new Chart(canvas, {
    type: 'bar',
    data: {
      labels: cities,
      datasets: [
        { label: 'ECMWF', data: summaries.map(s => (s.ecmwf_match_rate*100).toFixed(1)), backgroundColor: '#4ade80', borderRadius: 4 },
        { label: 'GFS', data: summaries.map(s => (s.gfs_match_rate*100).toFixed(1)), backgroundColor: '#60a5fa', borderRadius: 4 },
        { label: 'ICON', data: summaries.map(s => (s.icon_match_rate*100).toFixed(1)), backgroundColor: '#facc15', borderRadius: 4 },
        { label: 'â‰¥2/3 Cons', data: summaries.map(s => (s.consensus2_rate*100).toFixed(1)), backgroundColor: '#a78bfa', borderRadius: 4 },
        { label: '3/3 Cons', data: summaries.map(s => s.consensus3_total > 0 ? (s.consensus3_rate*100).toFixed(1) : 0), backgroundColor: '#fb923c', borderRadius: 4 },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { labels: { color: '#888', font: { size: 10 } } } },
      scales: {
        x: { ticks: { color: '#555' }, grid: { display: false } },
        y: { min: 0, max: 100, ticks: { color: '#555', callback: v => v + '%' }, grid: { color: '#1a1a2a' } }
      }
    }
  });
}

function renderMonthlyChart(results) {
  if (backtestCharts['monthly']) backtestCharts['monthly'].destroy();
  const canvas = document.getElementById('bt-monthly-chart');
  if (!canvas) return;

  // Group by city+month
  const byCityMonth = {};
  results.forEach(r => {
    if (r.consensus_count < 2) return;
    const month = r.target_date.slice(0, 7);
    const key = `${r.city}:${month}`;
    if (!byCityMonth[key]) byCityMonth[key] = { city: r.city, month, correct: 0, total: 0 };
    byCityMonth[key].total++;
    if (r.consensus_correct) byCityMonth[key].correct++;
  });

  const months = [...new Set(Object.values(byCityMonth).map(v => v.month))].sort();
  const cityColors = { paris: '#60a5fa', london: '#4ade80', chicago: '#facc15', 'buenos-aires': '#fb923c' };

  const datasets = CITIES.map(city => ({
    label: city.name,
    data: months.map(m => {
      const v = byCityMonth[`${city.slug}:${m}`];
      return v && v.total > 0 ? +((v.correct / v.total) * 100).toFixed(1) : null;
    }),
    borderColor: cityColors[city.slug],
    backgroundColor: cityColors[city.slug] + '33',
    borderWidth: 2,
    pointRadius: 4,
    tension: 0.3,
    spanGaps: true,
  }));

  backtestCharts['monthly'] = new Chart(canvas, {
    type: 'line',
    data: { labels: months, datasets },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { labels: { color: '#888', font: { size: 10 } } } },
      scales: {
        x: { ticks: { color: '#555' }, grid: { color: '#1a1a2a' } },
        y: { min: 0, max: 100, ticks: { color: '#555', callback: v => v + '%' }, grid: { color: '#1a1a2a' } }
      }
    }
  });
}

// ============================================================
// MODEL DROPS TAB â€” Forecast timeline showing model updates
// ============================================================
// ============================================================
// MARKET LAG TAB â€” How fast does the market react to model drops?
// ============================================================
let effChart = null;
let effCity = 'london';

async function loadEfficiency() {
  const area = document.getElementById('effArea');
  const filtersEl = document.getElementById('effFilters');
  const city = CITIES.find(c => c.slug === effCity);

  filtersEl.innerHTML = CITIES.map(c =>
    `<div class="tab ${effCity === c.slug ? 'active' : ''}" onclick="effCity='${c.slug}';loadEfficiency()" style="font-size:0.8em">${c.flag} ${c.name}</div>`
  ).join('');

  // Get all resolved dates (from trades or just dates with both forecasts + market prices)
  const { data: forecasts } = await sb.from('forecasts')
    .select('target_date, model, temp_value, bucket, collected_at')
    .eq('city', effCity)
    .order('collected_at', { ascending: true });

  const { data: prices } = await sb.from('market_prices')
    .select('target_date, bucket, price, collected_at')
    .eq('city', effCity)
    .order('collected_at', { ascending: true });

  if (!forecasts?.length || !prices?.length) {
    area.innerHTML = `<div class="card" style="text-align:center;padding:40px">
      <div style="font-size:1.5em;margin-bottom:8px">â±ï¸</div>
      <div style="color:#888">Not enough data yet. Need market prices + forecasts for the same dates.</div>
      <div style="color:#555;font-size:0.85em;margin-top:8px">The collector stores market prices every 15 min. After a few days, this tab will show how quickly the market absorbs new forecast information.</div>
    </div>`;
    return;
  }

  // Group forecasts by target_date â†’ snapshots with consensus bucket over time
  const forecastsByDate = {};
  for (const f of forecasts) {
    if (!forecastsByDate[f.target_date]) forecastsByDate[f.target_date] = [];
    forecastsByDate[f.target_date].push(f);
  }

  // Group prices by target_date â†’ bucket â†’ [{time, price}]
  const pricesByDate = {};
  for (const p of prices) {
    if (!pricesByDate[p.target_date]) pricesByDate[p.target_date] = {};
    if (!pricesByDate[p.target_date][p.bucket]) pricesByDate[p.target_date][p.bucket] = [];
    pricesByDate[p.target_date][p.bucket].push({ time: p.collected_at, price: p.price });
  }

  // Find dates with enough data (both forecasts and prices over time)
  const dates = Object.keys(pricesByDate).filter(d => forecastsByDate[d]?.length > 0).sort().reverse();

  if (dates.length === 0) {
    area.innerHTML = `<div class="card" style="text-align:center;padding:40px;color:#888">No overlapping forecast + price data found.</div>`;
    return;
  }

  let html = `<div style="margin-bottom:16px;color:#888;font-size:0.85em">
    â±ï¸ Shows how the market price of the ECMWF-predicted bucket evolves over time, relative to model drop windows.
    <br>If the market is slow to react, there's a trading window after each drop.
  </div>`;

  // Show the most recent date with a chart
  const targetDate = dates[0];

  // Find ECMWF consensus bucket at each snapshot
  const fcSnapshots = forecastsByDate[targetDate];
  const ecmwfSnapshots = fcSnapshots.filter(f => f.model === 'ecmwf');
  const latestEcmwfBucket = ecmwfSnapshots.length > 0 ? ecmwfSnapshots[ecmwfSnapshots.length - 1].bucket : null;

  if (!latestEcmwfBucket || !pricesByDate[targetDate]?.[latestEcmwfBucket]) {
    area.innerHTML = `<div class="card" style="padding:20px;color:#888">No price history for ECMWF bucket "${latestEcmwfBucket}" on ${targetDate}</div>`;
    return;
  }

  const bucketPrices = pricesByDate[targetDate][latestEcmwfBucket];

  // Build chart: price of ECMWF bucket over time
  html += `<div class="card" style="margin-bottom:16px">
    <div style="font-size:1.1em;font-weight:700;margin-bottom:4px">${city.flag} ${city.name} â€” ${targetDate}</div>
    <div style="font-size:0.8em;color:#666;margin-bottom:12px">Market price of <strong>${latestEcmwfBucket}</strong> (ECMWF predicted bucket) over time</div>
    <canvas id="effChart" height="280"></canvas>
  </div>`;

  // Also show all available dates as a table summary
  html += `<div class="card">
    <div style="font-size:1em;font-weight:700;margin-bottom:12px">ğŸ“‹ Price Movement Summary</div>
    <div style="font-size:0.8em;color:#666;margin-bottom:8px">How did the ECMWF bucket price change from first observation to last?</div>
    <table style="width:100%;border-collapse:collapse;font-size:0.85em">
      <thead><tr style="border-bottom:1px solid #2e2e3e">
        <th style="text-align:left;padding:6px;color:#888">Date</th>
        <th style="text-align:left;padding:6px;color:#888">ECMWF Bucket</th>
        <th style="text-align:center;padding:6px;color:#888">First Price</th>
        <th style="text-align:center;padding:6px;color:#888">Last Price</th>
        <th style="text-align:center;padding:6px;color:#888">Î”</th>
        <th style="text-align:center;padding:6px;color:#888">Snapshots</th>
      </tr></thead><tbody>`;

  for (const d of dates.slice(0, 10)) {
    const ecmwf = forecastsByDate[d]?.filter(f => f.model === 'ecmwf');
    const bucket = ecmwf?.length > 0 ? ecmwf[ecmwf.length - 1].bucket : '?';
    const bp = pricesByDate[d]?.[bucket];
    if (!bp || bp.length < 2) continue;

    const first = bp[0];
    const last = bp[bp.length - 1];
    const delta = last.price - first.price;
    const deltaColor = delta > 0.05 ? '#4ade80' : delta < -0.05 ? '#f87171' : '#888';

    html += `<tr style="border-bottom:1px solid #1e1e2e;cursor:pointer" onclick="effDate='${d}';renderEffChart('${d}')">
      <td style="padding:6px">${d}</td>
      <td style="padding:6px">${bucket}</td>
      <td style="text-align:center;padding:6px">${(first.price*100).toFixed(1)}Â¢</td>
      <td style="text-align:center;padding:6px">${(last.price*100).toFixed(1)}Â¢</td>
      <td style="text-align:center;padding:6px;color:${deltaColor};font-weight:600">${delta > 0 ? '+' : ''}${(delta*100).toFixed(1)}Â¢</td>
      <td style="text-align:center;padding:6px;color:#666">${bp.length}</td>
    </tr>`;
  }

  html += `</tbody></table></div>`;

  area.innerHTML = html;

  // Store data globally for re-rendering chart on date click
  window._effData = { forecastsByDate, pricesByDate, city };
  renderEffChart(targetDate);
}

function renderEffChart(targetDate) {
  const { forecastsByDate, pricesByDate, city } = window._effData || {};
  if (!forecastsByDate || !pricesByDate) return;

  const canvas = document.getElementById('effChart');
  if (!canvas || typeof Chart === 'undefined') return;
  if (effChart) { effChart.destroy(); effChart = null; }

  const ecmwfSnapshots = (forecastsByDate[targetDate] || []).filter(f => f.model === 'ecmwf');
  const latestBucket = ecmwfSnapshots.length > 0 ? ecmwfSnapshots[ecmwfSnapshots.length - 1].bucket : null;
  if (!latestBucket) return;

  const bucketPrices = pricesByDate[targetDate]?.[latestBucket] || [];
  if (bucketPrices.length === 0) return;

  // Price line
  const priceData = bucketPrices.map(p => ({ x: new Date(p.time), y: p.price * 100 }));

  // ECMWF forecast change markers
  const fcMarkers = [];
  let prevVal = null;
  for (const f of ecmwfSnapshots) {
    if (prevVal !== null && Math.abs(f.temp_value - prevVal) > 0.05) {
      fcMarkers.push({ x: new Date(f.collected_at), y: null, label: `ECMWF: ${prevVal.toFixed(1)}â†’${f.temp_value.toFixed(1)}` });
    }
    prevVal = f.temp_value;
  }

  // Drop window annotations
  const baseDate = targetDate;
  const prevDate = new Date(new Date(targetDate).getTime() - 86400000).toISOString().slice(0, 10);
  const annotations = {};

  // Model drop windows for both prev day and target day
  const windows = [
    { label: 'ECMWF 12z (D-1)', date: prevDate, hour: 17.33, color: 'rgba(74,222,128,0.08)' },
    { label: 'GFS 18z (D-1)', date: prevDate, hour: 22, color: 'rgba(96,165,250,0.08)' },
    { label: 'GFS 00z', date: baseDate, hour: 4, color: 'rgba(96,165,250,0.08)' },
    { label: 'ECMWF 00z', date: baseDate, hour: 5.5, color: 'rgba(74,222,128,0.08)' },
    { label: 'GFS 06z', date: baseDate, hour: 10, color: 'rgba(96,165,250,0.08)' },
  ];

  for (const w of windows) {
    const xMin = new Date(w.date + 'T00:00:00Z');
    xMin.setUTCHours(Math.floor(w.hour), (w.hour % 1) * 60);
    const xMax = new Date(xMin.getTime() + 45 * 60000);
    annotations[`win_${w.label}`] = {
      type: 'box', xMin, xMax,
      backgroundColor: w.color, borderWidth: 0,
      label: { display: true, content: w.label, position: { x: 'center', y: 'start' }, color: '#555', font: { size: 9 } },
    };
  }

  // ECMWF change markers as vertical lines
  for (let i = 0; i < fcMarkers.length; i++) {
    annotations[`fc_${i}`] = {
      type: 'line', xMin: fcMarkers[i].x, xMax: fcMarkers[i].x,
      borderColor: '#4ade80', borderWidth: 1, borderDash: [4, 4],
      label: { display: true, content: fcMarkers[i].label, position: 'start', color: '#4ade80', font: { size: 9 } },
    };
  }

  const datasets = [{
    label: `${latestBucket} price`,
    data: priceData,
    borderColor: '#60a5fa',
    backgroundColor: 'rgba(96,165,250,0.1)',
    borderWidth: 2,
    pointRadius: 2,
    pointHoverRadius: 5,
    fill: true,
    tension: 0.2,
  }];

  // Update card title
  const titleEl = canvas.parentElement?.querySelector('div:first-child');
  if (titleEl) titleEl.textContent = `${city.flag} ${city.name} â€” ${targetDate}`;
  const subtitleEl = canvas.parentElement?.querySelector('div:nth-child(2)');
  if (subtitleEl) subtitleEl.innerHTML = `Market price of <strong>${latestBucket}</strong> (ECMWF predicted bucket) over time`;

  effChart = new Chart(canvas, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      interaction: { mode: 'nearest', intersect: false },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            title: ctx => new Date(ctx[0].parsed.x).toLocaleString('en-GB', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) + ' UTC',
            label: ctx => `${ctx.parsed.y.toFixed(1)}Â¢`,
          },
        },
        annotation: { annotations },
      },
      scales: {
        x: {
          type: 'time',
          time: { unit: 'hour', displayFormats: { hour: 'MMM d HH:mm' } },
          ticks: { color: '#888', maxRotation: 45 },
          grid: { color: '#1e1e2e' },
          title: { display: true, text: 'UTC', color: '#666' },
        },
        y: {
          min: 0,
          ticks: { color: '#888', callback: v => v.toFixed(0) + 'Â¢' },
          grid: { color: '#1e1e2e' },
          title: { display: true, text: 'Market price', color: '#666' },
        },
      },
    },
  });
}

let dropsChart = null;
let dropsCity = 'london';
let dropsDate = null; // auto-pick tomorrow

async function loadDrops() {
  const area = document.getElementById('dropsArea');
  const filtersEl = document.getElementById('dropsFilters');

  // Determine dates to offer (today + next 2 days)
  const dates = getDates();
  if (!dropsDate) dropsDate = dates[1] || dates[0]; // default to tomorrow

  // Render filter buttons
  filtersEl.innerHTML = CITIES.map(c =>
    `<div class="tab ${dropsCity === c.slug ? 'active' : ''}" onclick="dropsCity='${c.slug}';loadDrops()" style="font-size:0.8em">${c.flag} ${c.name}</div>`
  ).join('') +
  `<span style="color:#444;margin:0 4px">|</span>` +
  dates.map(d =>
    `<div class="tab ${dropsDate === d ? 'active' : ''}" onclick="dropsDate='${d}';loadDrops()" style="font-size:0.8em">${d.slice(5)}</div>`
  ).join('');

  const city = CITIES.find(c => c.slug === dropsCity);
  if (!city) return;

  // Fetch all forecast snapshots for this city+date
  const { data, error } = await sb
    .from('forecasts')
    .select('model, temp_value, bucket, collected_at, lead_days')
    .eq('city', dropsCity)
    .eq('target_date', dropsDate)
    .order('collected_at', { ascending: true });

  if (error || !data || data.length === 0) {
    area.innerHTML = `<div class="card" style="text-align:center;padding:40px">
      <div style="font-size:1.5em;margin-bottom:8px">ğŸ””</div>
      <div style="color:#888">${error ? 'Error: ' + error.message : `No forecast data yet for ${city.name} on ${dropsDate}`}</div>
    </div>`;
    return;
  }

  const u = city.unit === 'F' ? 'Â°F' : 'Â°C';

  // Group by model
  const byModel = {};
  for (const row of data) {
    if (!byModel[row.model]) byModel[row.model] = [];
    byModel[row.model].push(row);
  }

  // Detect drops (value changes)
  const drops = [];
  for (const [model, rows] of Object.entries(byModel)) {
    let prev = null;
    for (const row of rows) {
      if (prev && Math.abs(row.temp_value - prev.temp_value) > 0.05) {
        drops.push({
          model,
          time: row.collected_at,
          from: prev.temp_value,
          to: row.temp_value,
          fromBucket: prev.bucket,
          toBucket: row.bucket,
          delta: row.temp_value - prev.temp_value,
          bucketChanged: prev.bucket !== row.bucket,
        });
      }
      prev = row;
    }
  }

  // Build HTML
  let html = '';

  // Timeline chart
  html += `<div class="card" style="margin-bottom:16px">
    <div style="font-size:1.1em;font-weight:700;margin-bottom:4px">${city.flag} ${city.name} â€” ${dropsDate}</div>
    <div style="font-size:0.8em;color:#666;margin-bottom:12px">Forecast snapshots over time Â· Each point is a collector reading</div>
    <canvas id="dropsChart" height="280"></canvas>
  </div>`;

  // Drops log
  html += `<div class="card">
    <div style="font-size:1em;font-weight:700;margin-bottom:12px">ğŸ”” Forecast Changes (${drops.length})</div>`;

  if (drops.length === 0) {
    html += `<div style="color:#666;font-size:0.85em">No forecast shifts detected yet for this date.</div>`;
  } else {
    html += `<div style="display:flex;flex-direction:column;gap:6px">`;
    for (const d of drops.reverse()) {
      const time = new Date(d.time).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' });
      const color = d.bucketChanged ? '#f87171' : '#facc15';
      const icon = d.bucketChanged ? 'ğŸš¨' : 'âš ï¸';
      const arrow = d.delta > 0 ? 'â†‘' : 'â†“';
      html += `<div style="display:flex;align-items:center;gap:10px;padding:6px 10px;background:#0a0a12;border-radius:6px;border-left:3px solid ${color}">
        <span style="font-size:1.1em">${icon}</span>
        <span style="color:#888;font-size:0.8em;min-width:50px">${time}z</span>
        <span style="font-weight:700;text-transform:uppercase;min-width:55px;font-size:0.85em">${d.model}</span>
        <span style="font-size:0.9em">${d.from.toFixed(1)} â†’ ${d.to.toFixed(1)}${u}</span>
        <span style="color:${d.delta > 0 ? '#4ade80' : '#60a5fa'};font-size:0.85em">${arrow}${Math.abs(d.delta).toFixed(2)}</span>
        ${d.bucketChanged ? `<span style="background:#3b1111;color:#f87171;padding:1px 6px;border-radius:4px;font-size:0.75em">BUCKET FLIP: ${d.fromBucket} â†’ ${d.toBucket}</span>` : ''}
      </div>`;
    }
    html += `</div>`;
  }
  html += `</div>`;

  // Model drop schedule reference
  html += `<div style="margin-top:12px;color:#555;font-size:0.75em;text-align:center">
    ECMWF: 00z ~05:30 Â· 12z ~17:30 &nbsp;|&nbsp; GFS: 00z ~04:00 Â· 06z ~10:00 Â· 12z ~16:00 Â· 18z ~22:00 &nbsp;|&nbsp; ICON: 00z ~04:00 Â· 06z ~10:00 Â· 12z ~16:00 Â· 18z ~22:00
  </div>`;

  area.innerHTML = html;

  // Render chart
  const canvas = document.getElementById('dropsChart');
  if (!canvas || typeof Chart === 'undefined') return;

  if (dropsChart) { dropsChart.destroy(); dropsChart = null; }

  const modelColors = { ecmwf: '#4ade80', gfs: '#60a5fa', icon: '#facc15' };

  // Build datasets
  const datasets = Object.entries(byModel).map(([model, rows]) => ({
    label: model.toUpperCase(),
    data: rows.map(r => ({ x: new Date(r.collected_at), y: r.temp_value })),
    borderColor: modelColors[model] || '#888',
    backgroundColor: modelColors[model] || '#888',
    borderWidth: 2,
    pointRadius: 3,
    pointHoverRadius: 6,
    tension: 0.1,
    stepped: 'before',
  }));

  // Add bucket boundary lines
  const allVals = data.map(d => d.temp_value);
  const minVal = Math.floor(Math.min(...allVals)) - 1;
  const maxVal = Math.ceil(Math.max(...allVals)) + 1;
  const annotations = {};
  for (let b = minVal; b <= maxVal; b++) {
    const boundary = city.unit === 'F' ? Math.floor(b / 2) * 2 : b;
    const yVal = city.unit === 'F' ? boundary + 0.5 : boundary + 0.5;
    annotations[`bucket_${b}`] = {
      type: 'line',
      yMin: yVal,
      yMax: yVal,
      borderColor: 'rgba(255,255,255,0.06)',
      borderWidth: 1,
      borderDash: [4, 4],
      label: {
        display: b === Math.round((minVal + maxVal) / 2),
        content: `${boundary}${u} bucket`,
        position: 'start',
        color: '#444',
        font: { size: 10 },
      },
    };
  }

  // Add drop window bands
  const dropWindowDefs = [
    { label: 'ECMWF 00z', hour: 5, dur: 0.75, color: 'rgba(74,222,128,0.06)' },
    { label: 'GFS/ICON 06z', hour: 10, dur: 0.75, color: 'rgba(96,165,250,0.06)' },
    { label: 'GFS/ICON 12z', hour: 16, dur: 0.75, color: 'rgba(96,165,250,0.06)' },
    { label: 'ECMWF 12z', hour: 17.33, dur: 0.75, color: 'rgba(74,222,128,0.06)' },
    { label: 'GFS/ICON 18z', hour: 22, dur: 0.75, color: 'rgba(96,165,250,0.06)' },
    { label: 'GFS/ICON 00z', hour: 4, dur: 0.5, color: 'rgba(96,165,250,0.06)' },
  ];

  // Use the date range from data
  const firstTime = new Date(data[0].collected_at);
  const baseDate = firstTime.toISOString().slice(0, 10);

  for (const w of dropWindowDefs) {
    const xMin = new Date(baseDate + 'T00:00:00Z');
    xMin.setUTCHours(Math.floor(w.hour), (w.hour % 1) * 60);
    const xMax = new Date(xMin.getTime() + w.dur * 3600000);
    annotations[`win_${w.label}`] = {
      type: 'box',
      xMin, xMax,
      backgroundColor: w.color,
      borderWidth: 0,
      label: {
        display: true,
        content: w.label,
        position: { x: 'center', y: 'start' },
        color: '#555',
        font: { size: 9 },
      },
    };
  }

  dropsChart = new Chart(canvas, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      interaction: { mode: 'nearest', intersect: false },
      plugins: {
        legend: { labels: { color: '#888' } },
        tooltip: {
          callbacks: {
            title: ctx => new Date(ctx[0].parsed.x).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }) + ' UTC',
            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}${u} â†’ ${getBucket(ctx.parsed.y, city.unit)}`,
          },
        },
        annotation: { annotations },
      },
      scales: {
        x: {
          type: 'time',
          time: { unit: 'hour', displayFormats: { hour: 'HH:mm' }, tooltipFormat: 'HH:mm' },
          ticks: { color: '#888' },
          grid: { color: '#1e1e2e' },
          title: { display: true, text: 'UTC', color: '#666' },
        },
        y: {
          ticks: { color: '#888', callback: v => v.toFixed(1) + u },
          grid: { color: '#1e1e2e' },
          title: { display: true, text: `Forecast ${u}`, color: '#666' },
        },
      },
    },
  });
}

let accuracyLoaded = false;
let accuracyChart = null;
async function loadAccuracy() {
  if (accuracyLoaded) return;
  const area = document.getElementById('accuracyArea');

  // Fetch accuracy data â€” look for time-of-day rows (model like "ecmwf_0h")
  const { data, error } = await sb.from('forecast_accuracy').select('*').order('city').order('model');
  if (error || !data || data.length === 0) {
    area.innerHTML = `<div class="card" style="text-align:center;padding:40px">
      <div style="font-size:1.5em;margin-bottom:8px">ğŸ“Š</div>
      <div style="color:#888">${error ? 'Error: ' + error.message : 'No accuracy data yet.'}</div>
    </div>`;
    return;
  }

  // Separate time-of-day rows (e.g. "ecmwf_0h") from legacy lead-time rows
  const byRunRows = data.filter(r => r.model.match(/_\d+h$/));
  const cityMeta = Object.fromEntries(CITIES.map(c => [c.slug, c]));

  // Group: city â†’ baseModel â†’ hoursBack â†’ row
  const byCityModelHours = {};
  for (const row of byRunRows) {
    const match = row.model.match(/^(.+?)_(\d+)h$/);
    if (!match) continue;
    const [, baseModel, hours] = match;
    const h = parseInt(hours);
    if (!byCityModelHours[row.city]) byCityModelHours[row.city] = {};
    if (!byCityModelHours[row.city][baseModel]) byCityModelHours[row.city][baseModel] = {};
    byCityModelHours[row.city][baseModel][h] = row;
  }

  let html = '';

  html += `<div style="margin-bottom:16px;color:#888;font-size:0.85em">
    ğŸ• D+0 accuracy by hours before resolution. Source: 90-day Previous Runs API backfill.
    <br>ECMWF updates every 12h. GFS/ICON update every 6h. Earlier runs = less accurate.
  </div>`;

  // Model run schedule reference
  html += `<div class="card" style="margin-bottom:16px;padding:12px">
    <div style="font-size:0.85em;font-weight:600;color:#aaa;margin-bottom:8px">Model Run â†’ Hours Before Resolution</div>
    <div style="font-size:0.8em;color:#888;display:grid;grid-template-columns:auto 1fr;gap:4px 16px">
      <span style="color:#4ade80;font-weight:600">ECMWF</span><span>0h = latest run (00z or 12z) Â· 12h = prev run Â· 24h = 2 runs ago Â· ...</span>
      <span style="color:#60a5fa;font-weight:600">GFS</span><span>0h = latest run Â· 6h = prev run Â· 12h = 2 runs ago Â· 18h = 3 runs ago Â· ...</span>
      <span style="color:#facc15;font-weight:600">ICON</span><span>0h = latest run Â· 6h = prev run Â· 12h = 2 runs ago Â· 18h = 3 runs ago Â· ...</span>
    </div>
  </div>`;

  for (const [citySlug, models] of Object.entries(byCityModelHours)) {
    const city = cityMeta[citySlug] || { name: citySlug, flag: '' };

    html += `<div class="card" style="margin-bottom:16px">
      <div style="font-size:1.1em;font-weight:700;margin-bottom:12px">${city.flag || ''} ${city.name || citySlug}</div>`;

    for (const baseModel of ['ecmwf', 'gfs', 'icon']) {
      const hourData = models[baseModel];
      if (!hourData) continue;
      const hours = Object.keys(hourData).map(Number).sort((a, b) => a - b);
      const modelColor = { ecmwf: '#4ade80', gfs: '#60a5fa', icon: '#facc15' }[baseModel];

      html += `<div style="font-size:0.85em;font-weight:600;color:${modelColor};margin-bottom:6px;margin-top:${baseModel === 'ecmwf' ? '0' : '12px'}">${baseModel.toUpperCase()}</div>`;
      html += `<div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px">`;

      for (const h of hours) {
        const row = hourData[h];
        const rate = (row.bucket_match_rate * 100).toFixed(1);
        const mae = row.mae != null ? row.mae.toFixed(2) : '-';
        const color = row.bucket_match_rate >= 0.80 ? '#4ade80' : row.bucket_match_rate >= 0.60 ? '#facc15' : '#f87171';
        const bg = row.bucket_match_rate >= 0.80 ? '#0f3d0f' : row.bucket_match_rate >= 0.60 ? '#3d3d0f' : '#3d0f0f';

        html += `<div style="background:${bg};border:1px solid ${color}33;border-radius:8px;padding:8px 12px;text-align:center;min-width:70px">
          <div style="font-size:0.7em;color:#888;margin-bottom:2px">${h}h before</div>
          <div style="font-size:1.3em;font-weight:700;color:${color}">${rate}%</div>
          <div style="font-size:0.7em;color:#666">MAE ${mae}</div>
          <div style="font-size:0.65em;color:#555">n=${row.sample_size}</div>
        </div>`;
      }
      html += `</div>`;
    }

    html += `</div>`;
  }

  // Accuracy decay chart
  html += `<div class="card" style="margin-bottom:16px">
    <div style="font-size:1.1em;font-weight:700;margin-bottom:12px">ğŸ“‰ Accuracy Decay: Hours Before Resolution</div>
    <canvas id="accuracyChart" height="300"></canvas>
  </div>`;

  const latest = data.reduce((max, r) => r.computed_at > max ? r.computed_at : max, '');
  html += `<div style="text-align:center;color:#555;font-size:0.75em;margin-top:8px">
    Last computed: ${latest ? new Date(latest).toLocaleString() : 'never'}
  </div>`;

  area.innerHTML = html;

  // Render chart
  const canvas = document.getElementById('accuracyChart');
  if (canvas && typeof Chart !== 'undefined') {
    if (accuracyChart) { accuracyChart.destroy(); accuracyChart = null; }

    const datasets = [];
    const cityColors = { london: { ecmwf: '#4ade80', gfs: '#86efac', icon: '#bbf7d0' },
                         paris: { ecmwf: '#60a5fa', gfs: '#93c5fd', icon: '#bfdbfe' },
                         chicago: { ecmwf: '#facc15', gfs: '#fde047', icon: '#fef08a' } };

    // Only show ECMWF for clarity (main model)
    for (const city of CITIES) {
      const ecmwfData = byCityModelHours[city.slug]?.ecmwf;
      if (!ecmwfData) continue;
      const hours = Object.keys(ecmwfData).map(Number).sort((a, b) => a - b);
      datasets.push({
        label: `${city.flag} ${city.name} ECMWF`,
        data: hours.map(h => ({ x: h, y: ecmwfData[h].bucket_match_rate * 100 })),
        borderColor: cityColors[city.slug]?.ecmwf || '#888',
        backgroundColor: cityColors[city.slug]?.ecmwf || '#888',
        borderWidth: 2,
        pointRadius: 5,
        pointHoverRadius: 8,
        tension: 0.3,
      });
    }

    accuracyChart = new Chart(canvas, {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        interaction: { mode: 'nearest', intersect: false },
        plugins: {
          legend: { labels: { color: '#888' } },
          tooltip: { callbacks: {
            title: ctx => `${ctx[0].parsed.x}h before resolution`,
            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}%`,
          }},
          annotation: {
            annotations: {
              tradeable: {
                type: 'line', yMin: 70, yMax: 70,
                borderColor: 'rgba(250,204,21,0.3)', borderWidth: 1, borderDash: [6, 4],
                label: { display: true, content: 'Min tradeable (~70%)', position: 'end', color: '#666', font: { size: 10 } },
              },
            },
          },
        },
        scales: {
          x: {
            type: 'linear', reverse: true, min: 0,
            title: { display: true, text: 'Hours before resolution', color: '#666' },
            ticks: { color: '#888', stepSize: 6, callback: v => `${v}h` },
            grid: { color: '#1e1e2e' },
          },
          y: {
            min: 10, max: 100,
            title: { display: true, text: 'Bucket match rate', color: '#666' },
            ticks: { color: '#888', callback: v => v + '%' },
            grid: { color: '#1e1e2e' },
          },
        },
      },
    });
  }

  accuracyLoaded = true;
}

async function loadDepthSlots() {
  const slots = document.querySelectorAll('.depth-slot');
  for (const el of slots) {
    const city = el.dataset.city;
    const dateStr = el.dataset.date;
    const conf = parseFloat(el.dataset.conf);

    const { data: depth } = await sb.from('order_depth')
      .select('*').eq('city', city).eq('target_date', dateStr)
      .order('collected_at', { ascending: false }).limit(1);

    if (!depth || depth.length === 0) { el.innerHTML = '<span style="color:#444">No depth data yet</span>'; continue; }
    const d = depth[0];
    const levels = JSON.parse(d.levels || '[]');
    const time = new Date(d.collected_at).toLocaleString('en-GB', { hour:'2-digit', minute:'2-digit', hour12:false, timeZone:'UTC' });

    if (levels.length === 0) {
      el.innerHTML = `<span style="color:#f87171">No asks â‰¤${(d.max_entry*100).toFixed(0)}Â¢</span> | Best ask: ${d.best_ask ? (d.best_ask*100).toFixed(1)+'Â¢' : 'â€”'} <span style="color:#333">@${time}</span>`;
      continue;
    }

    let h = `<div style="color:#666;font-size:0.9em;margin-bottom:4px">ğŸ“Š AVAILABLE SIZE (with edge) <span style="color:#333">@${time} UTC</span></div>`;
    h += '<div style="display:flex;flex-wrap:wrap;gap:6px">';
    for (const l of levels) {
      const levelEdge = (conf - l.price) * 100;
      h += `<div style="background:#0a0a12;border:1px solid #1a1a2a;border-radius:4px;padding:4px 8px;text-align:center">`;
      h += `<div style="color:#60a5fa;font-weight:600">${(l.price*100).toFixed(1)}Â¢</div>`;
      h += `<div style="color:#888">${l.size.toFixed(0)} shares</div>`;
      h += `<div style="color:#4ade80;font-size:0.85em">+${levelEdge.toFixed(0)}% edge</div>`;
      h += `</div>`;
    }
    h += '</div>';
    h += `<div style="margin-top:4px;color:#555">Total: ${d.available_size.toFixed(0)} shares ($${d.available_cost.toFixed(0)}) across ${d.num_levels} levels</div>`;
    el.innerHTML = h;
  }
}

// Init
refresh().then(() => loadDepthSlots());
setInterval(() => refresh().then(() => loadDepthSlots()), 5 * 60 * 1000);
</script>
</body>
</html>
